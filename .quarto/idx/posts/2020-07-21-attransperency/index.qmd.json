{"title":"Austrian Parliament: MPs transparency and conflict of interest report","markdown":{"yaml":{"title":"Austrian Parliament: MPs transparency and conflict of interest report","description":"Analysis of Austria MP's transparency reports.","date":"07-21-2020","categories":["Austria","OCR","web scraping"],"image":"preview.png"},"headingText":"Context","containsRefs":false,"markdown":"\n\n\nRecently, at the end of June, the Austrian Parliament published its annual report on MPs' additional sources of revenue and pertaining activities (see [here](https://www.parlament.gv.at/POOL/SWBRETT/ZUSD/BezBegrBVGPar9-NR.pdf){target=\"_blank\"}). The publication is mandatory by law, and basically seeks to curtail potential conflicts of interest and to increase transparency as to MPs' activities outside of parliament. While the list comes, unsurprisingly, with a number of caveats [^1], and by itself can hardly constitute a watertight safeguard against the various 'undemocratic temptations', the report nevertheless seems to provide interesting data on MPs' financial statuses and professional machinations. All in all enough reason to give it a closer look, i.e. a blog post.[^2] Note that I will focus only on Austria's lower chamber (*Nationalrat*) in this post. If time permits, I'll follow up with one on the upper chamber (*Bundesrat*) at a later point.\n\n[^1]: For details see [here.](https://www.parlament.gv.at//POOL/SWBRETT/25020/0010/BezBegrBVGPar9Erkl-NR.pdf#page=1){target=\"_blank\"}\n\n[^2]: Halfway through the blog, I realized that the transparency website meineabgeordneten.at had alreay published a similar, although non-technial blog on this matter. If you speak German, have a look [here](https://www.meineabgeordneten.at/News/detail/Nationalrat_Nebeneinkommen_Offenlegung_2019){target=\"_blank\"}. In a previous version I also had wrongly identified the gender of one MP. Kindly, Marion Breitschopf from meineabgeordneten.at helped clarifying this.\n\nIf you're not that much interested in the R code, simply collapse the code chunks. The entire code for the analysis will be on my github account ([link](https://github.com/werkstattcodes){target=\"_blank\"}). For any questions, comments etc. feel free to send me a direct message on twitter ([link](https://twitter.com/zoowalk){target=\"_blank\"}).\n\n# Setup\n\nBut step by step: Let's first take care of the necessary R packages and blog/rmarkdown setup.\n\n<details closed>\n\n<summary>Code: Load packages</summary>\n\n```{r echo=TRUE, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(extrafont)\nloadfonts(device = \"win\", quiet = T)\nlibrary(hrbrthemes)\nhrbrthemes::update_geom_font_defaults(family = \"Roboto Condensed\",\n                                      size=3)\nlibrary(scales)\nlibrary(knitr)\nlibrary(paletteer)\nlibrary(ggtext)\nlibrary(glue)\nlibrary(gt)\nlibrary(DT)\nlibrary(reactable)\nlibrary(reactablefmtr)\nlibrary(pdftools)\nlibrary(lemon)\nlibrary(ggiraph)\n\n```\n\n</details>\n\n<details closed>\n\n<summary>Code: Define rmarkdown options</summary>\n\n```{r setup, echo = T}\n# knit_hooks$set(wrap = function(before, options, envir) {\n#   if (before) {\n#     paste0(\"<\", options$wrap, \">\")\n#   } else {\n#     paste0(\"</\", options$wrap, \">\")\n#   }\n# })\n\n# knitr::opts_chunk$set(\n#   echo = TRUE,\n#   fig.align = \"left\",\n#   # fig.height = 5,\n#   # fig.width = 7,\n#   out.width = \"100%\",\n#   message = FALSE,\n#   warning = FALSE\n# )\n# \n# options(width = 180, dplyr.width = 150)\n```\n\n</details>\n\n<details closed>\n\n<summary>Code: Define plot theme</summary>\n\n```{r echo=F}\nplot_bg_color <- \"white\"\n\ntheme_post <- function() {\n  hrbrthemes::theme_ipsum_rc() +\n    theme(\n      plot.background = element_rect(fill = plot_bg_color, color=NA),\n      panel.background = element_rect(fill = plot_bg_color, color=NA),\n      plot.margin =ggplot2::margin(l = 0, unit = \"cm\"),\n      plot.title = element_text(\n        color = \"grey20\",\n        face = \"bold\",\n        margin =ggplot2::margin(l = 0, unit = \"cm\"),\n        size = 13\n      ),\n      plot.title.position = \"plot\",\n      plot.subtitle = element_text(\n        color = \"grey50\",\n        margin =ggplot2::margin(t = 0.2, b = 0.3, unit = \"cm\"),\n        size = 11\n      ),\n      plot.caption = element_text(\n        color = \"grey50\",\n        size = 8,\n        hjust = c(0)\n      ),\n      plot.caption.position = \"panel\",\n      axis.title.x = element_text(angle = 0,\n                                         color=\"grey50\",\n                                         hjust=1),\n      axis.text.x = element_text(size = 9, \n                                 color = \"grey50\"),\n      axis.title.y = element_blank(),\n      axis.text.y = element_text(size = 9,\n                                 color=\"grey50\"),\n      panel.grid.minor.x = element_blank(),\n      panel.grid.major.x = element_blank(),\n      panel.grid.minor.y = element_blank(),\n      panel.spacing = unit(0.25, \"cm\"),\n      panel.spacing.y = unit(0.25, \"cm\"),\n      strip.text = element_text(\n        angle = 0,\n        size = 9,\n        vjust = 1,\n        face = \"bold\"\n      ),\n      legend.title = element_text(\n        color = \"grey30\",\n        face = \"bold\",\n        vjust = 1,\n        size = 7\n      ),\n      legend.text = element_text(\n        size = 7,\n        color = \"grey30\"\n      ),\n      legend.justification = \"left\",\n      legend.box = \"horizontal\", # arrangement of multiple legends\n      legend.direction = \"vertical\",\n      legend.margin =ggplot2::margin(l = 0, t = 0, unit = \"cm\"),\n      legend.spacing.y = unit(0.07, units = \"cm\"),\n      legend.text.align = 0,\n      legend.box.just = \"top\",\n      legend.key.height = unit(0.2, \"line\"),\n      legend.key.width = unit(0.5, \"line\"),\n      text = element_text(size = 5)\n    )\n}\n\n\nmy_caption=c(\"data: Austrian Parliament, Liste gemäß § 9 Bezügebegrenzungs-BVG, 2020. \\nanalysis: Roland Schmidt | @zoowalk | https://werk.statt.codes\")\n```\n\n</details>\n\n# Data extraction\n\nAs so often, one of the main challenges to actually analyze available data is to 'liberate' the information of interest from the format in which they are provided. The Parliament's report comes as a pretty 'untidy' pdf with subheadings etc., a format hardly conducive for further analysis. Here's one MP's declaration from the report:\n\n![](list_example - Copy.PNG){width=\"100%\"}\n\nEssentially, the table provides four relevant pieces of information: *1) an income category*, which groups MPs' additional income (which is within the scope of the legal reporting obligations and in addition to their salary as an MP) according to their average monthly income in 2019;\n\nThe income categories are:\n\n```{r echo=FALSE}\ndata.frame(\n  category = c(1L, 2L, 3L, 4L, 5L),\n  income.bracket = c(\n    \"1-1,000\", \"1,001-3,500\",\n    \"3,501-7,000\", \"7,001-10,000\", \">10,000\")) %>% \n    gt() %>% \n  gt::cols_label(income.bracket=md(\"**income bracket (Euro)**\"),\n                 category=md(\"**category**\")) %>% \n  gt::cols_align(align=\"right\",\n                 columns = c(income.bracket))\n```\n\nAnd lists of **2) executive positions** in stock companies, private limited companies, foundations or saving banks held by each MP; **3) other activities** from which MPs generate income; and **4) honorary activities** which yield no income (but could potentially nevertheless lead to some conflict of interest).\n\nExtracting data from pdfs has been the topic of at least one of my previous posts (see [here](https://werk.statt.codes/post/bih-voting-behavior-of-mps-in-house-of-representatives/){target=\"_blank\"}), and again the primary tool for the job is the wonderful `pdftools` package. Rather than seeking to extract tables from the pdf (e.g. with `tabulizer` ), I convert the content of each page of the report to a long text string and subsequently extract the parts of interest by means of `stringr` and regex. However, as I'll explain below, this approach was only suited to do some part of the task at hand.\n\nLet's start by retrieving the raw text.\n\n```{r code_folding=\"Code: Extract text from pdfs\"}\nmy_path <- here::here(\"posts\", \"2020-07-21-attransperency\", \"BezBegrBVGPar9-NR.pdf\")\n\ndf_all <- pdftools::pdf_text(pdf = my_path) %>%\n  enframe(.,\n    name = NULL,\n    value = \"text_raw\"\n  ) %>%\n  mutate(text_raw = str_replace_all(text_raw, \"\\\\h+\", \" \"))\n```\n\nThe code above provides us with a tibble containing as many rows as the report has pages (186). The expression `str_replace_all(text_raw, \"\\\\h+\", \" \")` replaces all horizontal white space with a single space, but keeps line breaks (\\\\n and \\\\r). The latter will be needed at a later stage when it comes to identifying the location of data of interest and extract them.[^3]\n\n[^3]: I am grateful to the respondents to my pertaining question on [stackoverflow](https://stackoverflow.com/questions/62678640/stringr-remove-multiple-spaces-but-keep-linebreaks-n-r/62679016#62679016){target=\"_blank\"}\n\nEach row is one long string containing all the information from only one single page on an MP. However, note that the declarations of some MPs span over multiple pages, hence their data is contained in multiple strings. This is something we have to account for when crunching numbers during the actual analysis. Here one example for the data on one MP. Use the horizontal scrollbar to get an idea of the strings composition.\n\n```{r echo=FALSE, tidy=FALSE, R.options=list(width=10), code_folding=NULL}\nstringr::str_wrap(df_all$text_raw[1], 10)\n```\n\n## Get income category\n\nAs a first step, let's extract the name of the MPs and the income category from the raw strings obtained above. The code chunk below is the pertaining code, making use of `stringr` and `regex`. Note the `(?s)` term in the regex expressions. While `.` would match any pattern but not line breaks, the `(?s)` alters this limitation and forces `.` to match also `\\n` and `\\r`.[^4]\n\n[^4]: See [here](https://stackoverflow.com/questions/159118/how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression/45981809#45981809){target=\"_blank\"} for a very helpful answer on SO.\n\n\n```{r, code_folding=FALSE}\ndf_all <- df_all %>%\n  mutate(name = str_extract(text_raw, regex(\"(?<=Einkommenskategorie)(?s).*(?=für das Jahr)\", ignore_case = T)) %>%\n    str_remove(., \"\\\\(i\\\\)\") %>%\n    str_trim()) %>%\n  mutate(income_category_19_raw = str_extract(text_raw, regex(\"(?<=2019:\\\\s?)\\\\S\"))) %>% \n  mutate(income_category_19=case_when(income_category_19_raw==\"-\" ~ \"0\",\n  .default = income_category_19_raw))  %>%\n  # mutate(income_category_19=income_category_19_raw) %>%\n  replace_na(., list(income_category_19=\"missing\")) %>%\n  select(-income_category_19_raw)\n  \n```\n\n\n\nAs already highlighted, since the declarations of some MPs run over multiple pages and are hence included several times in the above output, we have to limit the result to one row per MP. This is what `distinct()` does in the code chunk below.\n\n```{r code_folding=FALSE}\ndf_income <- df_all %>%\n  select(name, income_category_19) %>%\n  distinct()\n\nnrow(df_all)\nnrow(df_income)\n```\n\n\n## Missing income data\n\nLet's have a first, quick look at the information obtained so far:\n\n```{r, code_folding=\"Code: Number of MPs per income bracket\"}\ntbl_income <- df_income %>% \n  count(income_category_19) %>% \n  gt() %>% \n  gt::cols_label(income_category_19=md(\"**income category**\"),\n                 n=md(\"**number of MPs**\")) \n```\n\n\n```{r echo=FALSE, code_folding=NULL}\ntbl_income\n```\n\nBefore digging into frequencies of the income categories etc, a note on the missing observations. In ten instances, MPs did not report their income for 2019. Here are the ten MPs with missing income data.\n\n```{r, code_folding=\"Code: MPs with with missing income data\"}\ndf_income_missing <- df_income %>% \n  filter(income_category_19==\"missing\") %>% \n  mutate(family_name=str_remove(name, \",.*$\") %>% \n           str_extract(., \"\\\\S*$\")) \n  \ntbl_missing <- df_income_missing %>% \n  select(name, income_category_19) %>% \n  gt() %>% \n  cols_label(income_category_19=md(\"**income bracket**\"),\n             name=md(\"**MP**\")) %>% \n  gt::cols_align(align=\"center\",\n                 columns = vars(income_category_19))\n```\n\n\n```{r echo=FALSE, code_folding=NULL}\ntbl_missing\n```\n\nOne possible explanation for missing income data could be that these MPs have joined parliament only after the reporting period, i.e. in 2020 (I mean, there couldn't be any other possibility, no?). To check this, we need to obtain the dates of each MP's entry to parliament. Initially, I expected that such data should be readily available, but I must have been looking at the wrong places... Anyway, never waste an opportunity to scrap data.\n\nThe website of the Austrian Parliament provides a list of all (current and previous) MPs. This list is provided in an xml format from which we can obtain the links to each MP's individual biographical page. From these bios, we can subsequently extract the data when MP's entered the parliament. Not a bad detour...or, as a saying in German goes, Umwege erhöhen die Ortskenntnisse...(something like 'detours increase your local knowledge'.)\n\n```{r include=FALSE}\n# readr::write_rds(df_mp_dates, path=here::here(\"posts\", \"2020-07-21-attransperency\", \"MP_dates.rds\"))\n\ndf_mp_dates <- readr::read_rds(file=here::here(\"posts\", \"2020-07-21-attransperency\", \"MP_dates.rds\"))\n```\n\n```{r eval=FALSE}\nlibrary(xml2)\nlibrary(rvest)\nlink <- \"https://www.parlament.gv.at/WWER/PARL/J1918/filter.psp?view=RSS&jsMode=&xdocumentUri=&filterJq=&view=&NRBR=ALLE&GP=XXVII&R_WF=FR&FR=ALLE&W=W&M=M&listeId=8&FBEZ=FW_008\"\n\n#parse info from parliament's website\ndata <- xml2::read_xml(link)\n\n#extract name of MPs\ndf_title <- data %>% \n  xml2::xml_find_all(\"//title\") %>% \n  html_text() %>% \n  enframe(., \n          name=\"id\",\n          value=\"title\")\n\n#extract link to bio\ndf_link <- data %>% \n  xml2::xml_find_all(\"//link\") %>% \n  html_text() %>% \n  enframe(., \n          name=\"id\",\n          value=\"link\")\n\n#combine both to one dataframe\ndf <- df_title %>% \n  left_join(., df_link,\n            by=\"id\")\n\n#remove non-MP relevant rows\ndf <- df %>% \n  filter(str_detect(link, \"PAD_\")) %>% \n  mutate(link=str_trim(link))\n\n#define function to extract MP's entry/exit dates from biography\nfn_get_dates <- function(x) {\n  read_html(x) %>% \n  html_nodes(xpath=\"/html/body/div[1]/div[5]/div[1]/div[1]/div[3]/div[2]/div[2]/ul[1]/li/div/text()[2]\") %>% \n  html_text()\n}\n\ndf\n\n#apply funciton to all links\ndf_mp_dates <- df %>%\n  mutate(mp_dates=map(link, ~fn_get_dates(.)))\n\n\n```\n\n```{r include=FALSE}\n#extract family name for subsequent merger with income data\ndf_mp_dates <- df_mp_dates %>% \n  mutate(family_name=str_trim(title) %>% \n           str_extract(., regex(\"^\\\\S*\")))\n\n#merge with MPs whose income data is missing\ndf_income_missing <- df_income_missing %>% \n  left_join(., df_mp_dates %>%\n              select(family_name, mp_dates),\n            by=c(\"family_name\"=\"family_name\")) %>% \n  select(name, mp_dates) %>% \n  mutate(mp_dates=unlist(mp_dates) %>% \n           str_remove(., regex(\"(?<=\\\\d{4}).*\")))\n\n```\n\n```{r echo=FALSE, code_folding=NULL}\ndf_income_missing %>% \n  gt() %>% \n  gt::cols_label(mp_dates=md(\"**entry date**\"),\n                 name=md(\"**MP**\"))\n```\n\nAnd indeed. From the result above, we see that all those MPs who haven't submitted any income information were not MPs in 2019 *for a full month* (this is the requirement stipulated in the pertaining regulation). Hence, for the subsequent analysis on income data, when can safely disregard these MPs.\n\n```{r echo=TRUE, code_folding=\"Code: Remove MPs joining outside of reporting period\"}\nnrow(df_income)\ndf_income <- df_income %>% \n  filter(!name %in% df_income_missing$name)\nnrow(df_income)\n```\n\n\n# MPs' gender\n\n```{r include=FALSE}\ngender_colors <- c(female=\"firebrick\", male=\"grey\", missing=\"#BEBEBE\") \n\ndf_income_categories <- tibble::tribble(\n  ~income_category_19, ~category_values, ~category_labels,\n                   0L,              \"0\",              \"0\",\n                   1L,        \"1-1,000\",             \">1\",\n                   2L,    \"1,001-3,500\",            \">1K\",\n                   3L,    \"3,501-7,000\",          \">3.5K\",\n                   4L,   \"7,001-10,000\",            \">7K\",\n                   5L,        \">10,000\",           \">10K\"\n  ) \n\nincome_categories <- df_income_categories %>% \n  select(1, 2) %>%\n  deframe()\n\n\nincome_categories_short <- df_income_categories %>% \n  mutate(income_label=paste0(\n    \"[\",income_category_19,\"]\",\n    \"\\n\",\n    category_labels, \"€\")) %>% \n  select(1, 4) %>%\n  deframe()\n\n```\n\nLet's have a gender-sensitive look at the income data. With the `gender`package we are able to infer with some acceptable margin of error MPs' gender from their first names. Names which were not (properly) recognized by the package I corrected manually in the code chunk below.\n\n```{r, code_folding=FALSE}\n#get a clean name, without any academic or prefessional titles\ndf_income <- df_income %>% \n  mutate(name_family=str_remove(name, \",.*$\") %>% \n           str_extract(., \"\\\\S*$\"),\n         .after=name) %>% \n  mutate(name_clean=name %>% str_remove(., regex(\",.*$\")) %>% \n           str_remove_all(., regex(\"\\\\S*\\\\.\")) %>% \n           str_remove_all(., regex(\"\\\\(.*\\\\)\")) %>% \n           str_trim()) \n\n\nlibrary(gender)\n#extract first name and apply gender function to it\ndf_income <- df_income %>% \n  mutate(first_name=str_extract(name_clean, regex(\"^\\\\S*\"))) %>% \n  mutate(name_gender=map(first_name, possibly(gender,\n                                              otherwise=\"missing\"))) \n\n# manually correct for some missing gender data\ndf_income<- df_income %>% \n  unnest_wider(name_gender,names_repair=\"universal\") %>% \n  rename(name=name...1) %>% \n  select(-contains(\"year\"), -contains(\"proportion\"), -ends_with(\"7\")) %>% \n  mutate(gender=case_when(str_detect(name, \"Brandstötter\")==TRUE ~ \"female\",\n                          str_detect(name, \"El-Nagashi\")==TRUE ~ \"female\",\n                          str_detect(name, \"Sibylle\")==TRUE ~ \"female\",\n                          str_detect(name, \"Himmelbauer\")~\"female\",\n                          str_detect(name, \"Karlheinz\")==TRUE ~ \"male\",\n                          str_detect(name, \"Jörg\")==TRUE ~ \"male\",\n                          str_detect(name, \"Volker\")==TRUE ~ \"male\",\n                          str_detect(name, \"Gertraud\")==TRUE ~ \"female\",\n                          str_detect(name, \"Nurten\")==TRUE ~ \"female\",\n                          str_detect(name, \"Süleyman\")==TRUE ~ \"male\",\n                          str_detect(name, \"Ribo\")==TRUE ~ \"female\",\n                          TRUE ~ as.character(gender)))\n```\n\n\n## Female share per income group\n\nWhat the subsequent analysis reveals is that the share of women per income category decreases the further we move up the income ladder. While there is almost gender parity in the income category 0, womens' shares decrease continuously up to category 4.\n\n\n```{r, code_folding=T}\ndf_gender <- df_income %>% \n  group_by(income_category_19, gender) %>% \n  summarise(n_obs=n()) %>% \n  mutate(n_rel_category=n_obs/sum(n_obs)) %>% \n  group_by(gender) %>% \n  mutate(n_gender=sum(n_obs)) %>% \n  ungroup() %>% \n  mutate(n_rel_gender=n_obs/n_gender)\n\npl_gender_category <- df_gender %>% \n  # filter(gender==\"female\") %>% \n  mutate(gender=fct_rev(gender)) %>% \n  ggplot()+\n  labs(title=glue(\"Austrian Nationalrat: Share of <span style  = color:{gender_colors['female']}>female</span> and <span style = color:{gender_colors['male']}>male</span> MPs per income category\"),\n       subtitle=str_wrap(\"Income: average monthly income from professional positions in addition to MPs' salary. Absolute number of female MPs in brackets. Only lower chamber. Data for 2019.\", 105),\n       y=\"[income category] average monthly income\",\n       caption=my_caption)+\n  geom_bar(aes(y=income_category_19,\n               x=n_obs,\n               fill=gender),\n           stat=\"identity\",\n           position=\"fill\")+\n  geom_text(data=. %>% filter(gender==\"female\"),\n            aes(y=income_category_19,\n                x=n_rel_category-0.01,\n                label=paste0(round(n_rel_category,2) %>% \n                  percent(scale=100),\n                  \"\\n(\",\n                  n_obs,\n                  \")\")),\n            color=\"white\",\n            lineheight=0.6,\n            hjust=1,\n            stat=\"identity\")+\n  geom_vline(xintercept = .5,\n             color=\"white\",\n             linetype=\"dashed\"\n             )+\n  scale_fill_manual(values=gender_colors)+\n  scale_x_continuous(label=scales::label_percent(),\n                     expand=expansion(mult=c(0, 0.05)))+\n  scale_y_discrete(labels=income_categories_short,\n                   expand=expansion(mult=c(0, 0)),\n                   position = \"left\")+\n  theme_post()+\n  theme(legend.position=\"none\",\n        plot.title=element_markdown(),\n        axis.title.x=element_blank(),\n        axis.title.y.left = element_text(angle = 90,\n                                         color=\"grey50\",\n                                         hjust=1),\n        axis.text.y.left = element_text(),\n        axis.text.y.right = element_blank(),\n        axis.title.y.right = element_blank(),\n        panel.grid.major.y  = element_blank())\n\n```\n\n```{r echo=FALSE, fig.height=6, fig.width=10, code_folding=NULL}\npl_gender_category\n\n```\n\n## Share of income groups per gender group\n\nAnother gender sensitive perspective is to look at the distribution of the MPs across income categories within each gender group (in contrast to within each income group as in the previous graph). The graph highlights the difference between female and male MPs in terms of the income categories. While the distribution for female MPs is skewed towards lower income categories, that for male MPs is more concentrated on income category 2 and 3. Furthermore, only 4.4 % of all female MPs have additional incomes falling into the two highest categories, 4 and 5. In contrast, 19 % of all male MPs have income from these categories.\n\n<details closed>\n\n<summary>Code: graph intra-gender distribution </summary>\n\n```{r, code_folding=F}\npl_gender_intra_dist <- df_gender %>% \n  ggplot()+\n  labs(title=\"Austrian Nationalrat: Distribution of MPs over income groups per gender\",\n       subtitle=str_wrap(\"Income: average monthly income from professional positions in addition to MPs' salary. Absolute number of MPs in brackets. Only lower chamber. Data for 2019.\", 105),\n       x=\"[income category] average monthly income\",\n       caption=my_caption)+\n  geom_bar(aes(x=income_category_19,\n               y=n_rel_gender,\n               fill=gender),\n           stat=\"identity\")+\n  geom_text(aes(x=income_category_19,\n                y=n_rel_gender+0.02,\n                label=paste0(percent(n_rel_gender, accuracy = 0.1),\n                             \"\\n\",\n                             \"(\", n_obs, \")\")),\n            lineheight=0.7,\n            stat=\"identity\")+\n  scale_fill_manual(values=gender_colors, \n                    na.value = \"grey30\")+\n  scale_x_discrete(labels=income_categories_short)+\n  scale_y_continuous(label=scales::label_percent(accuracy=1),\n                     expand=expansion(mult=c(0, 0.1)))+\n  facet_wrap(vars(gender))+\n  theme_post()+\n  theme(legend.position = \"none\",\n        axis.title.x = element_text(angle = 0,\n                                         color=\"grey50\",\n                                         hjust=1),)\n```\n\n</details>\n\n```{r echo=FALSE, code_folding=NULL}\npl_gender_intra_dist\n```\n\n# Party affiliation\n## Get MPs' party membership\n\nAs the next step to facilitate the analysis of the data, let's add MPs' party affiliation. I do this by importing the pertaining data from wikipedia's entry on Austria's current MP (the parliament's website was simply to messy for my liking). Here, the `rvest` package is our friend. Once the data on MP membership is retrieved, I merge it with MPs' income/transparency data. The key/identifier to merge both sets of data is an MP's name. To make this work, I had first to remove all academic/professional titles (it's Austria after all) and harmonize the sequence of first and family names.\n\n```{r, code_folding=\"Code: Get party affiliation\"}\nwiki_link <- \"https://de.wikipedia.org/wiki/Liste_der_Abgeordneten_zum_%C3%96sterreichischen_Nationalrat_(XXVII._Gesetzgebungsperiode)\"\n\nlibrary(rvest)\n\ndf_nr <- wiki_link %>% \n  read_html() %>% \n  html_nodes(\"table\") %>% \n  html_table(fill=TRUE) %>% \n  .[[1]] %>% \n  janitor::remove_empty(., which=c(\"cols\")) %>% \n  janitor::clean_names() %>% \n  as_tibble()\n\ndf_nr <- df_nr %>% \n  mutate(name_family=str_extract(name, regex(\"^\\\\S*\"))) %>% \n  select(contains(\"name\"), party=wahl_partei) %>% \n  mutate(name_first=str_remove(name, regex(\"\\\\S*\"))) %>% \n  mutate(name_clean=paste(name_first, name_family) %>% \n           str_trim() %>% str_squish()) %>% \n  mutate(name_clean=case_when(str_detect(name, \"Künsberg\")==TRUE ~ \"Martina Künsberg Sarre\",\n                               TRUE ~ as.character(name_clean))) \n  \n\n#manually adjust inconsistently spelled names\ndf_income <- df_income %>% \n  mutate(name_clean=case_when(str_detect(name, \"Nurten\")==TRUE ~ \"Nurten Yilmaz\",\n                               # str_detect(name, \"Künsberg\")==TRUE ~ \" Martina Künsberg Sarre\",\n                              str_detect(name, \"Herr\")==TRUE ~ \"Julia Herr\",\n                              str_detect(name, \"Schellhorn\")==TRUE ~ \"Sepp Schellhorn\",\n                              str_detect(name, \"Lercher\")==TRUE ~ \"Max Lercher\",\n                              str_detect(name, \"Niss\")==TRUE ~ \"Maria Niss\",\n                              TRUE ~ as.character(name_clean)))\n\ndf_income <- df_income %>% \n  left_join(., df_nr %>% \n              select(name_clean, party),\n            by=c(\"name_clean\"=\"name_clean\")) %>% \n  mutate(party=case_when(str_detect(name, \"Strache\")==T ~ \"independent\",\n                         TRUE ~ as.character(party))) %>% \n  ungroup()\n\ndf_income <- df_income %>% \n  mutate(party=fct_infreq(party))\n\n\n\n```\n\n\nBelow the result with all MPs, their party affiliation, and income data.\n\n```{r echo=FALSE, code_folding=NULL}\ndatatable(df_income %>% select(name, party, gender, income_category_19),\n          colnames=c(\"MP name\"=\"name\", \"income category\"=\"income_category_19\"),\n          filter=\"top\",\n          options=list(pageLength=10,\n                       columnDefs = list(list(className = 'dt-center', targets = 1:3,\n                                         searchable=TRUE))),\n          rownames = FALSE)\n```\n\n```{r include=FALSE}\nparty_colors <- c(FPÖ = \"#005DA8\", NEOS = \"#EA5290\", ÖVP = \"#5DC2CC\", SPÖ = \"#FC0204\", GRÜNE = \"#A3C630\",\n                  independent=\"grey80\")\n\n```\n\n## MPs' income category by party\n\nWith data on each MP's income category and party membership available, let's aggregate the data by parties. The graph below show the distribution of MPs over income categories per party in relative (and absolute) terms.\n\n```{r, code_folding=\"Code: plots on income categories\"}\ndf_agg <- df_income %>% \n  ungroup() %>%\n  mutate(income_category_19_fac=as_factor(income_category_19) %>% \n           fct_inseq()) %>% \n  mutate(party=fct_infreq(party)) %>% \n  group_by(income_category_19, party, .drop = F) %>% \n  summarise(n_obs=n()) %>% \n  group_by(party) %>% \n  mutate(n_obs_total=sum(n_obs)) %>% \n  mutate(n_obs_rel=n_obs/n_obs_total)\n\npl_rel <- df_agg %>% \n  ggplot()+\n  labs(title=\"Austrian Nationalrat: Relative number of MPs per income category and party\",\n    subtitle=str_wrap(\"Percentages are shares of each party's total number of members. Absolute numbers in brackets. Lower chamber only (Nationalrat). Data for 2019.\", 105),\n    x=\"[income category] average monthly income\",\n    caption=my_caption)+\n  geom_label(data=. %>% filter(n_obs_rel >0),\n            aes(x=party,\n                y=n_obs_rel+.3,\n                family=\"Roboto Condensed\",\n                group=party,\n                label=paste0(scales::percent(n_obs_rel,\n                                      accuracy=0.1),\n                            \"\\n\",\n                            \"(\", n_obs, \")\")\n                ),\n            fill=plot_bg_color,\n            label.size=0,\n            label.padding = unit(0.1, \"lines\"),\n            lineheight=0.7,\n            family=\"Roboto Condensed\",\n            position=position_dodge2(width = 1))+\n    geom_bar(aes(x=party,\n               y=n_obs_rel,\n               group=income_category_19,\n               fill=party),\n           position=position_dodge2(),\n           stat=\"identity\"\n           )+\n  scale_fill_manual(values=party_colors)+\n  scale_x_discrete(labels=abbreviate)+\n  scale_y_continuous(label=scales::label_percent(),\n                     # limits = c(0, 1.15),\n                     expand=expansion(mult=c(0, 0.15)))+\n  lemon::facet_rep_wrap(vars(income_category_19),                        labeller=labeller(income_category_19=map_chr(income_categories_short, ~str_remove_all(., regex(\"\\\\]|\\\\[\"))) %>% \n                                                                                             map_chr(., ~str_replace(., regex(\"\\\\\\n\"), \": \")) %>%\n                                                                                             map_chr(., ~paste0(\"Income category \", .))),\n                        ncol=2,\n                        repeat.tick.labels = TRUE)+\n  theme_post()+\n  theme(legend.position=\"none\",\n        axis.title.x = element_blank())\n```\n\n```{r}\n#| echo: false\n#| code-fold: false\n#| column: page-right\n\npl_rel\n```\n\nThe ÖVP features the smallest share of MPs with no additional income (income category 0, only 6.2 %) followed by the FPÖ (though with a substantially higher share of 26.7 %). In contrast, Greens and Neos feature with 45.5 % and 40 % the highest share of MPs in in this category (leaving aside, Philippa Strache, the one independent MP with no additional income). The ÖVP features the highest absolute numbers in income categories 3, 4 and 5. In contrast, there are no Green MPs with an income falling into category 4 or 5. Similarly, there is also not a single MP from the SPÖ with an income from category 5. What's noteworthy with Neos is that they feature a comparably large share of MPs from income category 0, but also the largest relative number of MPs from the highest income category (13.3 %; equal with that of the FPÖ).\n\n# MPs' further jobs\n\nThe subsequent part of the analysis will focus on MPs' additional professional positions, as provided by the transparency report. As outlined in the introduction, it provides details on MPs' additional 1) executive positions in stock companies, private limited companies, foundations or saving banks; this section further distinguishes between those executive positions which are remunerated and those which aren't. 2) other professional activities from which MPs generate income; and 3) (unpaid) honorary activities.\n\n## Extracting data\n\nExtracting MPs' additional professional positions from the pdfs has been somewhat challenging. Initially - I was actually about to post the blog - I thought I could retrieve the data again with the `pdf_text` function as done above. However, when double checking some of the obtained results with the original pdf, I had to realize that some of my obtained numbers were inflated. After some digging and more digging, it turned out that the error originated from professional positions with names running over more than one line, i.e. which have a line break. Since I initially had counted the number of lines of positions to get the number of positions, some positions were counted multiple times. This problem arose since I was not able to distinguish between line breaks within cells (position with a long name) and those line breaks which indicated a new cell/row in the pdf's table (different professional position).\n\nThe answer to this challenge is provided by the `pdf_data` function, also from the `pdftools` package. As the output below shows, the function provides you with x and y coordinates for the actual, physical location of each textbox (for details see [here](https://ropensci.org/technotes/2018/12/14/pdftools-20/){target=\"_blank\"}).\n\n```{r echo=FALSE, code_folding=NULL}\npdf_file <- pdftools::pdf_data(pdf = my_path) \ndatatable(pdf_file[[8]],\n          options=list(pageLength=10,\n                       columnDefs = list(list(className = 'dt-center', targets = 0:4)),\n                       list(className='dt_left', targets=5)),\n          rownames=FALSE)\n```\n\nTaking a closer look at the rows in the results, I noticed that the difference in y values for linebreaks within a cell (long position name) is different than that between cells (different position). While 'normal' line breaks result in a y value change of 11, new cells result in a higher change of the y value. Hence, the difference in y values can be used as an indicator for a new cell and hence a different professional position.\n\nTo make use of this difference, I first calculate the difference of y values per row (`line_diff`), and subsequently and indicator which turns 1 if the y difference exceeds 11 (`row_jump`). Finally, I accumulate the value of the indicator to get an indicator for each row (`row_indicator`). For an example see the output below.\n\n```{r, code_folding=\"Code: identifying new positions\"}\ndf_linebreaks <- pdf_file[[8]] %>%\n  select(y, text) %>% \n    arrange(y) %>%\n    mutate(line_diff = y - dplyr::lag(y, default = 0)) %>%\n    mutate(row_jump = case_when(\n      line_diff > 11 ~ 1,\n      TRUE ~ 0\n    )) %>%\n    mutate(row_indicator = cumsum(row_jump)) \n```\n\n```{r echo=FALSE, code_folding=NULL}\n# datatable(df_linebreaks,\n#           options=list(pageLength=10,\n#                        columnDefs = list(list(className = 'dt-center', targets = \"all\"))),\n#           rownames=FALSE)\n```\n\n```{r}\n#| echo: false\nlibrary(reactable)\nlibrary(reactablefmtr)\ndf_linebreaks %>%\nreactable(, theme=nytimes())\n```\n\n\nIn the next step, I group the data by the `row_indicator` and combine the different text parts with the same row indicator into one string. As a result, we get a dataframe where each row contains one row of the table (including those parts after the line break). Hooray!\n\n```{r paged.print=TRUE, code_folding=\"Code: Table with one row per position\"}\ndf_rows <- df_linebreaks %>% \n  group_by(row_indicator) %>%\n    summarise(text_combined = paste(text, collapse = \" \")) %>%\n    mutate(text_combined = text_combined %>% str_trim() %>% str_squish())\n```\n\n```{r, ech=F, code_folding=NULL}\ndf_rows\n```\n\nFrom this new dataframe we have to filter out those rows which contain the different professional positions we are interested in. To do this, I first extract the row number of those rows which contain the subheading of each nested table (on executive, other, and honorary positions). With row number values of these rows, I can subsequently filter out those rows which are located between the headings (= professional positions).\n\n```{r, code_folding=\"Code: row numbers of sub-headings\"}\n# headings\nheading_executive <- df_rows %>%\n    filter(str_detect(text_combined, regex(\"Leitende Stellung in\", ignore_case = T))) %>%\n    pull(row_indicator)\n\nheading_other <- df_rows %>%\n    filter(str_detect(text_combined, regex(\"SONSTIGE TÄTIGKEITEN\", ignore_case = T))) %>%\n    pull(row_indicator)\n\nheading_honorary <- df_rows %>%\n    filter(str_detect(text_combined, regex(\"ehrenamtlich\", ignore_case = T))) %>%\n    pull(row_indicator)\n  \nheading_executive\nheading_other\nheading_honorary\n```\n\n## Putting it all into a function\n\nI put all the above outlined (and subsequent) steps into a function which provides me with the number of positions per category for each MP. Have a look in the code chunk below. In a sense, it's the key element of the overall analysis.\n\n```{r, code_folding=\"Code: Function to extract positions\"}\nfn_get_positions <- function(x) {\n  d <- x %>%\n    arrange(y) %>%\n    mutate(line_diff = y - dplyr::lag(y, default = 0)) %>%\n    mutate(row_jump = case_when(\n      line_diff > 11 ~ 1,\n      TRUE ~ 0\n    )) %>%\n    mutate(row_indicator = cumsum(row_jump)) %>%\n    group_by(row_indicator) %>%\n    summarise(text_combined = paste(text, collapse = \" \")) %>%\n    mutate(text_combined = text_combined %>% str_trim() %>% str_squish())\n\n  # headings\n  heading_executive <- d %>%\n    filter(str_detect(text_combined, regex(\"Leitende Stellung in\", ignore_case = T))) %>%\n    pull(row_indicator)\n\n  heading_other <- d %>%\n    filter(str_detect(text_combined, regex(\"SONSTIGE TÄTIGKEITEN\", ignore_case = T))) %>%\n    pull(row_indicator)\n\n  heading_honorary <- d %>%\n    filter(str_detect(text_combined, regex(\"ehrenamtlich\", ignore_case = T))) %>%\n    pull(row_indicator)\n\n  # executive position\n  if (length(heading_executive)!=0 & length(heading_other!=0)) {\n    df_executive <- d %>%\n      filter(!str_detect(text_combined, regex(\"Rechtsträger Leitende Stellung\"))) %>%\n      filter(row_indicator > heading_executive) %>%\n      filter(row_indicator < heading_other) %>%\n      select(-row_indicator)\n\n    n_executive <- ifelse(df_executive %>%\n      filter(str_detect(text_combined, regex(\"^keine$\"))) %>%\n      nrow() == 0,\n    nrow(df_executive),\n    0\n    )\n  } else {\n    df_executive <- tibble(text_combined = NA)\n    n_executive <- NA\n  }\n\n  # non-remunerated positions\n  n_executive_non_remunerated <- df_executive %>% \n    filter(str_detect(text_combined, regex(\"\\\\*\"))) %>% \n    nrow()\n  \n  # other\n\n  if (length(heading_other)!=0 & length(heading_honorary)!=0) {\n    df_other <- d %>%\n      filter(!str_detect(text_combined, regex(\"Dienstgeber/Rechtsträger/\"))) %>%\n      filter(row_indicator > heading_other) %>%\n      filter(row_indicator < heading_honorary) %>%\n      select(-row_indicator)\n\n    n_other <- ifelse(df_other %>%\n      filter(str_detect(text_combined, regex(\"^keine$\"))) %>%\n      nrow() == 0,\n    nrow(df_other),\n    0\n    )\n  } else {\n    df_other <- tibble(text_combined = NA)\n    n_other <- NA\n  }\n\n  # honorary\n  if (length(heading_honorary!=0)) {\n    df_honorary <- d %>%\n      filter(!str_detect(text_combined, regex(\"Rechtsträger\"))) %>%\n      filter(!str_detect(text_combined, regex(\"\\\\(i\\\\) Näheres bei\\\\: Informationen\"))) %>%\n      filter(row_indicator > heading_honorary) %>%\n      select(-row_indicator)\n\n    n_honorary <- ifelse(df_honorary %>%\n      filter(str_detect(text_combined, regex(\"^keine$\"))) %>%\n      nrow() == 0,\n    nrow(df_honorary),\n    0\n    )\n  } else {\n    df_honorary <- tibble(text_combined = NA)\n    n_honorary <- NA\n  }\n\n  # combine retreived info\n  df <- tibble(\n    executive_positions = list(df_executive),\n    executive_n = n_executive,\n    executive_non_remunerated_n=n_executive_non_remunerated,\n    other_positions = list(df_other),\n    other_n = n_other,\n    honorary_positions = list(df_honorary),\n    honorary_n = n_honorary\n  )\n  df\n}\n\n```\n\nThis function is applied to our previous results of the `pdf_data` function. At the end, I combine these results with MPs' names and aggregate those reports of MPs which run over multiple pages. Et voila! You can use the arrows to sort the table and get e.g the top-10 MPs as to their number of executive positions.\n\n```{r, code_folding=\"Code: Apply function\"}\ndf_data <- pdf_file %>%\n  map_dfr(., fn_get_positions)\n\ndf_positions <- bind_cols(df_all, df_data)\n\n#rowwise & c_across to calculate rowwise sums\ndf_count <- df_positions %>% \n  group_by(name) %>% \n  summarize(across(ends_with(\"_n\"), \\(x) sum(x, na.rm=T))) %>% \n  rowwise() %>% \n  mutate(total_n=sum(c_across(ends_with(\"_n\")&!contains(\"remunerated\")), na.rm=T))\n```\n\n\n```{r echo=FALSE, code_folding=NULL, eval=F, include=F}\ndatatable(df_count,\n          colnames=c(\"MP name\"=\"name\",\n                     \"# executive pos (total)\"=\"executive_n\",\n                     \"# executive pos not remunerated\"=\"executive_non_remunerated_n\",\n                     \"# other pos\"=\"other_n\",\n                     \"# honorary pos\"=\"honorary_n\",\n                     \"total # pos\" = \"total_n\"),\n          options=list(pageLength=10,\n                       columnDefs = list(list(className = 'dt-center', targets = \"all\"))),\n          rownames=FALSE)\n```\n\n```{r}\n#| code-fold: true\n\ndf_count %>%\nreactable(.,\ncolumns = list(\n  name=colDef(name=\"MP name\"),\n  executive_n=colDef(name=\"# executive pos (total)\"),\n  executive_non_remunerated_n=colDef(name=\"# executive pos not remunerated\"),\n  honorary_n=colDef(name=\"# honorary pos\"),\n  total_n=colDef(name=\"total # pos\")\n  ),\n  theme=nytimes()\n)\n```\n\n\nNote that the table comprises 183 MPs, hence also includes those MPs which were not obliged to submit income data (see above, missing data).\n\n```{r include=FALSE}\ndf_count2 <- df_count %>% \n    mutate(name_clean=name %>% str_remove(., regex(\",.*$\")) %>% \n           str_remove_all(., regex(\"\\\\S*\\\\.\")) %>% \n           str_remove_all(., regex(\"\\\\(.*\\\\)\")) %>% \n           str_trim()) %>% \n    mutate(first_name=str_extract(name_clean, regex(\"^\\\\S*\"))) %>% \n    mutate(name_gender=map(first_name, possibly(gender,\n                                                otherwise=\"missing\"))) %>% \n  unnest_wider(name_gender, names_repair=\"universal\") %>% \n  rename(name=name...1) %>% \n  select(-contains(\"year\"), -contains(\"proportion\"), -ends_with(\"7\")) %>% \n  mutate(gender=case_when(str_detect(name, \"Brandstötter\")==TRUE ~ \"female\",\n                          str_detect(name, \"El-Nagashi\")==TRUE ~ \"female\",\n                          str_detect(name, \"Sibylle\")==TRUE ~ \"female\",\n                          str_detect(name, \"Himmelbauer\")~\"female\",\n                          str_detect(name, \"Karlheinz\")==TRUE ~ \"male\",\n                          str_detect(name, \"Jörg\")==TRUE ~ \"male\",\n                          str_detect(name, \"Volker\")==TRUE ~ \"male\",\n                          str_detect(name, \"Gertraud\")==TRUE ~ \"female\",\n                          str_detect(name, \"Nurten\")==TRUE ~ \"female\",\n                          str_detect(name, \"Süleyman\")==TRUE ~ \"female\",\n                          str_detect(name, \"Ribo\")==TRUE ~ \"female\",\n                          TRUE ~ as.character(gender))) %>% \n   mutate(name_clean=case_when(str_detect(name, \"Nurten\")==TRUE ~ \"Nurten Yilmaz\",\n                              str_detect(name, \"Herr\")==TRUE ~ \"Julia Herr\",\n                              str_detect(name, \"Schellhorn\")==TRUE ~ \"Sepp Schellhorn\",\n                              str_detect(name, \"Lercher\")==TRUE ~ \"Max Lercher\",\n                              str_detect(name, \"Niss\")==TRUE ~ \"Maria Niss\",\n                              TRUE ~ as.character(name_clean))) %>% \n  left_join(., df_nr %>% \n              select(name_clean, party),\n            by=c(\"name_clean\"=\"name_clean\")) %>%\n  mutate(party=case_when(str_detect(name, \"Strache\")==T ~ \"independent\",\n                         TRUE ~ as.character(party)))\n\ndf_position_long <- df_count2 %>% \n  select(name_clean, party, gender, ends_with(\"_n\")) %>% \n  pivot_longer(cols=ends_with(\"_n\"), \n               names_to=\"position\",\n               values_to=\"number\") %>% \n  mutate(party=fct_infreq(party))\n```\n\n## Paid positions and income category\n\nLet's have a look at MPs' number of paid positions and income category.\n\nPaid are the positions stated in the category 'other positions' and 'executive position'. As for the latter, however, the list also includes unpaid executive positions which are marked with an asterisk (\\*). Hence these positions have to be removed when calculating the total number of paid positions. For details see [below](#unpaid_executive).\n\nHover over the points in the plot below to get details on each individual MP. Note that the points are located randomly *within* each square to avoid overplotting.\n\n\n```{r, code_folding=\"Code: Number of paid positions and income category\"}\ndf_income_positions <- df_count2 %>% \n  left_join(., df_income %>% select(gender, income_category_19, name),\n            by=\"name\") %>% \n  select(name_clean, name, contains(\"executive\"), contains(\"other\"), party, income_category_19) %>% \n  mutate(positions_paid=(executive_n-executive_non_remunerated_n)+other_n)\n\ndf_income_positions <- df_income_positions %>% \n  filter(income_category_19!=\"missing\") %>% \n  mutate(across(.cols=c(positions_paid, income_category_19), list(fct=~as_factor(.) %>% fct_inseq)))\n  \nincome.key <- levels(factor(df_income_positions$income_category_19))\nposition.key <- seq(0, max(df_income_positions$positions_paid), 1) %>% \n  as.character()\n  \npl_income_positions <- df_income_positions %>% \n  mutate(income_category_19_fct=fct_rev(income_category_19_fct)) %>% \n  mutate(positions_paid_fct=fct_expand(positions_paid_fct, position.key) %>% \n           fct_inseq()) %>% \n  mutate(party=fct_infreq(party)) %>% \n  ggplot()+\n  labs(x=\"number of paid positions\",\n       y=\"[income category] average monthly income\",\n       title=\"Austrian Nationalrat: MPs' number of paid positions and income category\",\n       subtitle=\"Members of lower chamber only (Nationalrat). Data for 2019.\\nMove mouse over dots to get info on MPs.\",\n       caption=my_caption)+\n  geom_jitter_interactive(aes(x=positions_paid,\n                                       y=income_category_19,\n                                       color=party,\n                                       tooltip=paste0(name_clean, \" \", party, \"\\n\", \"paid positions: \", positions_paid, \"\\n\", \"income category: \", income_category_19)))+\n  scale_color_manual(values=party_colors)+\n  scale_y_discrete(labels=income_categories_short)+\n  facet_grid(income_category_19_fct ~ positions_paid_fct,\n             drop=FALSE,\n             scales=\"free\",\n             switch=\"x\")+\n  theme_post()+\n  theme(panel.border = element_rect(color = \"black\", fill = NA, linewidth = .5),\n        panel.grid.major = element_blank(),\n        panel.spacing.y = unit(0, \"cm\"),\n        panel.spacing.x = unit(0, \"cm\"),\n        legend.position = \"bottom\",\n        legend.title=element_blank(),\n        legend.direction = \"horizontal\",\n        axis.text.x = element_blank(),\n        axis.title.y=element_text(color=\"grey50\",\n                                  hjust=1,\n                                  angle=90),\n        strip.text.x = element_text(hjust=0.5, color=\"grey50\",\n                                    face=\"plain\"),\n        strip.text.y = element_blank())+\n  guides(color=guide_legend(nrow=1))\n```\n\n\n```{r}\n#| column: page-right\ngirafe(ggobj = pl_income_positions)\n\n```\n\nOverall, there seems to be a positive association between the number of positions and income category. However, bear in mind that we do not know how much income is generate from each specific position. We only know about the sum and shouldn't be tempted to infer any average salaries per position. E.g. while Herbert Fuchs' four paid positions yield in sum an income of more than 10,000 Euros per average month (income category 5), it could be that the bulk of the income sum originates from one particularly position only. This is particularly relevant if we think about comparing MPs within the same income category but different number of paid positions.\n\nA further qualifying note on the lower end of the income scale: Note that there are five curious cases of MPs having at least one paid position, but zero additional income. How can that be? Let's look at these five cases more closely.\n\n```{r, code_folding=\"Code: MPs with no income but paid positions\"}\ndf_mp5 <- df_income_positions %>% \n  filter(income_category_19==0) %>% \n  filter(positions_paid>0) %>% \n  select(contains(\"name\"), party, executive_n, positions_paid) %>% \n  left_join(., df_positions %>% select(name, executive_positions, other_positions), by=c(\"name\"=\"name\")) %>% \n  pivot_longer(cols=c(contains(\"positions\"), -positions_paid),\n               names_to=\"positions\",\n               values_to=\"positions_name\") %>% \n  mutate(positions_chr=map(positions_name, deframe) %>% \n           map_chr(., ~paste(., collapse=\";\\n \"))) %>% \n  select(-positions_name) %>% \n  pivot_wider(id_cols=c(name, party),\n              names_from=positions,\n              values_from=positions_chr)\n\ntb_mp5 <- df_mp5 %>% \n  gt() %>% \n  tab_header(\n    title=md(\"**MPs with zero income, but paid positions**\")) %>% \n   tab_footnote(footnote = \"Honorary positions exclude since unpaid.\",\n    locations = cells_title(group=\"title\")) %>% \n  cols_label(\"name\"=md(\"**MP**\"),\n             \"party\"=md(\"**party**\"),\n             \"executive_positions\"=md(\"**executive positons**\"),\n             \"other_positions\"=md(\"**other positions**\"))\n\n```\n\n```{r echo=FALSE}\ntb_mp5\n```\n\nAs for Neos MPs' Hoyos-Trauttmansdorff and Scherak a look at the parliament's list reveals that their declaration features an additional note indicating that both assumed their position only from April 2020 onward. Hence, there was no pertaining income for the 2019 category. Scherak's second executive position ('Margaretha Lupac - Stiftung') is unpaid as indicated by the \\*. Hence, these two cases are clear.\n\nThe other three cases are less clear to me. Eva-Maria Himmelbauer has an executive position in the Cloudcompany and there is no \\* sign which would indicate that the position was without remuneration. What's furthermore noteworthy, if you look at the table above, it states 'Ablauf der Meldefrist: Geschäftsführerin 23.11.2019'. Remarkably, this text is not visible in the original pdf on the parliament's website. I have no idea why and how, but the used `pdf_data` function extracted also 'hidden' text from the pdf. Whether this text was a comment to an e.g. Excel cell or a hidden row/column, I don't know. But irrespective of this, there is nothing in the additional text what would suggest - at leat to me - that Himmelbauer did not receive at least for one month a salary during the reporting period. Similarly, Markus Koza and Meri Dioski had both paid positions for their own parities up until 31.10.2019. Nevertheless, this income was not reported as indicated by the income category 0.\n\nTo be clear, I have no reason to think that there is any malice etc. behind these inconsistencies, and I assume there is some formal, regulatory explanation which hasn't been made explicit in the parliament's list. If anyone has an answer to this I would be keen to hear it.\n\n## Share of MPs with at least one additional position\n\nTo move on and, to get some contrast between parties, the barplot below indicates the percentage of MPs per party which do have at least one additional professional position.\n\n```{r, code_folding=\">Code: MP share w at least one add. position\"}\ndf_bar_position <- df_position_long %>% \n  filter(!position %in% c(\"executive_non_remunerated_n\",\n                        \"total_n\")) %>% \n  group_by(party, position) %>% \n  summarize(n_zero=length(number[number==0]),\n            n_non_zero=length(number[number!=0])) %>% \n  ungroup() %>% \n  mutate(perc=n_non_zero/(n_non_zero+n_zero)) %>% \n  mutate(position=fct_relevel(position, \"honorary_n\", after = 2))\n\npl_bar_position <- df_bar_position %>% \n  ggplot()+\n  labs(title=\"Austrian Nationalrat: Percentage of MPs with at least one additional position per party\",\n       subtitle=str_wrap(\"Percentages are shares of each party's total number of members. Absolute numbers in brackets. Lower chamber only (Nationalrat). Data for 2019.\", 105),\n       caption=my_caption)+\n  geom_bar(aes(x=party,\n               y=perc,\n               fill=party),\n           stat=\"identity\")+\n  geom_text(aes(x=party,\n               y=perc,\n               group=party,\n               label=paste0(perc %>% scales::percent(),\n                           \"\\n\",\n                           \"(\", n_non_zero,\")\")),\n            nudge_y = 0.05,\n            lineheight=0.7,\n           stat=\"identity\")+\n  scale_fill_manual(values=party_colors)+\n  scale_color_manual(values=party_colors)+\n  scale_y_continuous(label=scales::label_percent(accuracy = 1),\n                     expand=expansion(mult=c(0, 0.15)),\n                     breaks=seq(0,1,.25))+\n  scale_x_discrete(label=abbreviate)+\n  facet_wrap(vars(position),\n             labeller = labeller(position=c(\"executive_n\"=\"executive functions\",\"other_n\"=\"other activities\",\n                                            \"honorary_n\"=\"honorary positions\")))+\n  theme_post()+\n  theme(legend.position=\"none\",\n        axis.title.x = element_blank())\n  \n```\n\n```{r}\n#| column: page-right\npl_bar_position\n```\n\nAs far as *executive positions* are concerned, the relative numbers of Neos stand out. More than half of Neos' MPs have an executive position. In absolute numbers, the ÖVP with 26 MPs leads in this category.\n\nWhen it comes to *honorary positions*, there is a considerable gap between the three larger parties (ÖVP, SPÖ, FPÖ) and the two smaller ones (Greens, Neos). One possible explanation (which I have not looked into though) could be that larger parties have more party affiliated associations in which their MPs take up honorary positions. Maybe, and I am purely speculating here, the number of honorary positions is a function of a party's institutional width.\n\n## Executive positions {#unpaid_executive}\n\nBelow I further disaggregate executive positions into those which entail a salary and those which don't. In the parliament's report, executive positions without salary were marked with an asterisk (\\*). When retrieving the data above, I already accounted for this difference (`str_detect(., \"\\\\*\")`). The graph below now shows the percentage of MPs per party without executive positions, those with at least one executive position without salary (and no position with salary), and those with at least one remunerated executive position.\n\n```{r, code_folding=\"Code: different types of executive positions\"}\ndf_executive <- df_count2 %>% \n    select(party, contains(\"executive\")) %>% \n    mutate(executive_remunerated_n=executive_n-executive_non_remunerated_n) %>% \n  group_by(party) %>% \n  summarize(executive_no=length(executive_n[executive_n==0]),\n    remunerated_yes=length(executive_remunerated_n[executive_remunerated_n>0]),\n    remunerated_no=length(executive_remunerated_n[executive_remunerated_n==0 &\n                            executive_n>0])) %>% \n  ungroup() %>% \n  rowwise() %>% \n  mutate(total=sum(c_across(where(is.numeric)), na.rm=T)) \n\npl_executive <- df_executive %>% \n  pivot_longer(cols=-c(party, total),\n               values_to=\"number\",\n               names_to=\"remunerated\") %>% \n  mutate(party=fct_reorder(party, total) %>% fct_rev) %>%   mutate(perc=number/total) %>% \n  mutate(remunerated=case_when(str_detect(remunerated, regex(\"executive_no\"))==TRUE ~\"% MPs without executive positions\",                               str_detect(remunerated, regex(\"remunerated_no\"))==TRUE ~ \"% MPs with non-remunerated executive positions\",\n                               str_detect(remunerated, regex( \"remunerated_yes\"))==TRUE ~ \"% MPs with remunerated executive positions\",\n                               TRUE ~ as.character(remunerated))) %>% \n  mutate(remunerated=fct_relevel(remunerated,\n                                 \"% MPs with non-remunerated executive positions\", after = 1L) %>% fct_rev) %>%\n  ggplot()+\n  labs(title=\"Austrian Nationalrat: Percentage of MPs with different executive positions per party\",\n       subtitle=str_wrap(\"Percentages are shares of each party's total number of members. Absolute numbers in brackets. Lower chamber only (Nationalrat). Data for 2019.\", 105),\n       caption=my_caption)+\n  geom_bar(aes(x=party,\n               y=perc,\n               fill=party),\n           position=position_dodge(),\n           stat=\"identity\")+\n  geom_text(aes(x=party,\n                y=perc+.05,\n                label=paste0(scales::percent(perc,\n                                             accuracy = 0.1),\n                             \"\\n\",\n                            \"(\", number,\")\"),\n                group=remunerated),\n            lineheight=0.7,\n            position=position_dodge2(width = 1),\n            stat=\"identity\")+\n  scale_y_continuous(labels=scales::label_percent(),\n                     expand=expansion(mult=c(0, .1)))+\n  scale_x_discrete(labels=abbreviate)+\n  scale_fill_manual(values=party_colors)+\n  theme_post()+\n  theme(legend.position=\"none\",\n        axis.title.x = element_blank())+\n  facet_wrap(vars(remunerated),\n             labeller=label_wrap_gen(width=30))\n\n```\n\n\n```{r echo=FALSE}\npl_executive\n```\n\nNote that there is only one MP from the Greens with a paid executive position. Also, there are only three Socialdemocrats in this category. Again, the ÖVP features most MPs with a paid executive position in absolute terms, and Neos in relative terms.\n\n## Parties in comparison (Boxplot)\n\nThe boxplot below might be a bit of an overkill, but it gives us a more detailed overview of MPs' additional positions per party. Each dot indicates the number of positions which one specific MP holds in one category of professional positions. In addition, the median, mean, max and minimum values for each party/position combination are provided. Note the comparably high median value of honorary positions among SPÖ MPs.\n\n<details closed>\n\n<summary>Code: boxplots</summary>\n\n```{r echo=TRUE, fig.height=7, code_folding=F}\ndf_position_labels <- df_position_long %>% \n  filter(!position %in% c(\"executive_non_remunerated_n\",\n                        \"total_n\")) %>% \n  group_by(party, position) %>% \n  mutate(party=fct_infreq(party)) %>% \n  summarise(label_median=median(number),\n            label_mean=mean(number),\n            label_max=max(number),\n            label_min=min(number))\n\npl_box <- df_position_long %>% \n  filter(!position %in% c(\"executive_non_remunerated_n\",\n                        \"total_n\")) %>% \n  mutate(party=fct_infreq(party)) %>% \n  ggplot()+\n  labs(caption=my_caption,\n       title=\"Austrian Nationalrat: Number of MPs' other professional positions per party\",\n       subtitle=\"Members of lower chamber only (Nationalrat); Data for 2019.\",\n       x=\"MP's number of positions\")+\n  geom_boxplot(aes(y=party,\n                  x=number,\n                  group=party,\n                  color=party),\n               orientation=\"y\",\n               outlier.shape=NA,\n               width=0.1\n               )+\n  geom_jitter(aes(y=party,\n                  x=number,\n                  group=party,\n                  colour=party),\n              alpha=.2,\n              orientation=\"y\",\n              height=0.1\n              )+\n  geom_label(data=df_position_labels,\n            aes(y=1.2,\n                x=0,\n                group=party,\n                label=paste(\"median:\", round(label_median, 2),\n                            # \"\\n\",\n                            \"mean:\", round(label_mean, 2),\n                            # \"\\n\",\n                            \"min:\", round(label_min, 2),\n                            # \"\\n\",\n                            \"max:\", round(label_max, 2)\n                            )),\n            fill=plot_bg_color,\n            label.padding = unit(0.2,\"line\"),\n            label.r=unit(0.2,\"line\"),\n            label.size = 0,\n            family=\"Roboto Condensed\",\n            size=3,\n            vjust=0,\n            hjust=0,\n            orientation=\"y\",\n            lineheight=0.5)+\n  scale_color_manual(values=party_colors)+\n  scale_x_continuous(expand=expansion(mult=c(0, .2)))+\n  scale_y_discrete(expand=expansion(mult=c(0, .3)),\n                   label=abbreviate)+\n  theme_post()+\n  theme(legend.position = \"none\",\n        panel.grid.major.x = element_line(color=\"gray30\"),\n        panel.grid.major.y = element_blank(),\n        strip.text.y = element_blank())+\n  lemon::facet_rep_grid(party~position,\n                        repeat.tick.labels = TRUE,\n                        scales = \"free_y\",\n                        labeller = labeller(position=c(\"executive_n\"=\"executive functions\",\"other_n\"=\"other activities\",\n\"honorary_n\"=\"honorary positions\")))\n\n```\n\n</details>\n\n```{r echo=FALSE, fig.height=7, fig.width=10, code_folding=NULL}\npl_box\n```\n\n# Wrap up\n\nSo this has become a rather length blog entry. I hope there's been something useful in it for you as well. Again, the emphasis has been largely on various steps in R to extract and subsequently analyze the data of interest. If there's anything you feel like following up, feel free to let me know.\n\n```{r, include=F, eval=F}\ndf_nr<- df_count %>% \n  left_join(., df_income %>% \n              select(-ends_with(\"6\"), -first_name),\n            by=c(\"name\"=\"name\")) %>% \n  select(name, name_clean, party, gender, income_category_19, contains(\"_n\"))\n\n#readr::write_excel_csv2(df_nr, path=here::here(\"posts\", \"2020-07-21-attransperency\", \"NR.csv\"))\n\n\n```\n","srcMarkdownNoYaml":"\n\n# Context\n\nRecently, at the end of June, the Austrian Parliament published its annual report on MPs' additional sources of revenue and pertaining activities (see [here](https://www.parlament.gv.at/POOL/SWBRETT/ZUSD/BezBegrBVGPar9-NR.pdf){target=\"_blank\"}). The publication is mandatory by law, and basically seeks to curtail potential conflicts of interest and to increase transparency as to MPs' activities outside of parliament. While the list comes, unsurprisingly, with a number of caveats [^1], and by itself can hardly constitute a watertight safeguard against the various 'undemocratic temptations', the report nevertheless seems to provide interesting data on MPs' financial statuses and professional machinations. All in all enough reason to give it a closer look, i.e. a blog post.[^2] Note that I will focus only on Austria's lower chamber (*Nationalrat*) in this post. If time permits, I'll follow up with one on the upper chamber (*Bundesrat*) at a later point.\n\n[^1]: For details see [here.](https://www.parlament.gv.at//POOL/SWBRETT/25020/0010/BezBegrBVGPar9Erkl-NR.pdf#page=1){target=\"_blank\"}\n\n[^2]: Halfway through the blog, I realized that the transparency website meineabgeordneten.at had alreay published a similar, although non-technial blog on this matter. If you speak German, have a look [here](https://www.meineabgeordneten.at/News/detail/Nationalrat_Nebeneinkommen_Offenlegung_2019){target=\"_blank\"}. In a previous version I also had wrongly identified the gender of one MP. Kindly, Marion Breitschopf from meineabgeordneten.at helped clarifying this.\n\nIf you're not that much interested in the R code, simply collapse the code chunks. The entire code for the analysis will be on my github account ([link](https://github.com/werkstattcodes){target=\"_blank\"}). For any questions, comments etc. feel free to send me a direct message on twitter ([link](https://twitter.com/zoowalk){target=\"_blank\"}).\n\n# Setup\n\nBut step by step: Let's first take care of the necessary R packages and blog/rmarkdown setup.\n\n<details closed>\n\n<summary>Code: Load packages</summary>\n\n```{r echo=TRUE, message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(extrafont)\nloadfonts(device = \"win\", quiet = T)\nlibrary(hrbrthemes)\nhrbrthemes::update_geom_font_defaults(family = \"Roboto Condensed\",\n                                      size=3)\nlibrary(scales)\nlibrary(knitr)\nlibrary(paletteer)\nlibrary(ggtext)\nlibrary(glue)\nlibrary(gt)\nlibrary(DT)\nlibrary(reactable)\nlibrary(reactablefmtr)\nlibrary(pdftools)\nlibrary(lemon)\nlibrary(ggiraph)\n\n```\n\n</details>\n\n<details closed>\n\n<summary>Code: Define rmarkdown options</summary>\n\n```{r setup, echo = T}\n# knit_hooks$set(wrap = function(before, options, envir) {\n#   if (before) {\n#     paste0(\"<\", options$wrap, \">\")\n#   } else {\n#     paste0(\"</\", options$wrap, \">\")\n#   }\n# })\n\n# knitr::opts_chunk$set(\n#   echo = TRUE,\n#   fig.align = \"left\",\n#   # fig.height = 5,\n#   # fig.width = 7,\n#   out.width = \"100%\",\n#   message = FALSE,\n#   warning = FALSE\n# )\n# \n# options(width = 180, dplyr.width = 150)\n```\n\n</details>\n\n<details closed>\n\n<summary>Code: Define plot theme</summary>\n\n```{r echo=F}\nplot_bg_color <- \"white\"\n\ntheme_post <- function() {\n  hrbrthemes::theme_ipsum_rc() +\n    theme(\n      plot.background = element_rect(fill = plot_bg_color, color=NA),\n      panel.background = element_rect(fill = plot_bg_color, color=NA),\n      plot.margin =ggplot2::margin(l = 0, unit = \"cm\"),\n      plot.title = element_text(\n        color = \"grey20\",\n        face = \"bold\",\n        margin =ggplot2::margin(l = 0, unit = \"cm\"),\n        size = 13\n      ),\n      plot.title.position = \"plot\",\n      plot.subtitle = element_text(\n        color = \"grey50\",\n        margin =ggplot2::margin(t = 0.2, b = 0.3, unit = \"cm\"),\n        size = 11\n      ),\n      plot.caption = element_text(\n        color = \"grey50\",\n        size = 8,\n        hjust = c(0)\n      ),\n      plot.caption.position = \"panel\",\n      axis.title.x = element_text(angle = 0,\n                                         color=\"grey50\",\n                                         hjust=1),\n      axis.text.x = element_text(size = 9, \n                                 color = \"grey50\"),\n      axis.title.y = element_blank(),\n      axis.text.y = element_text(size = 9,\n                                 color=\"grey50\"),\n      panel.grid.minor.x = element_blank(),\n      panel.grid.major.x = element_blank(),\n      panel.grid.minor.y = element_blank(),\n      panel.spacing = unit(0.25, \"cm\"),\n      panel.spacing.y = unit(0.25, \"cm\"),\n      strip.text = element_text(\n        angle = 0,\n        size = 9,\n        vjust = 1,\n        face = \"bold\"\n      ),\n      legend.title = element_text(\n        color = \"grey30\",\n        face = \"bold\",\n        vjust = 1,\n        size = 7\n      ),\n      legend.text = element_text(\n        size = 7,\n        color = \"grey30\"\n      ),\n      legend.justification = \"left\",\n      legend.box = \"horizontal\", # arrangement of multiple legends\n      legend.direction = \"vertical\",\n      legend.margin =ggplot2::margin(l = 0, t = 0, unit = \"cm\"),\n      legend.spacing.y = unit(0.07, units = \"cm\"),\n      legend.text.align = 0,\n      legend.box.just = \"top\",\n      legend.key.height = unit(0.2, \"line\"),\n      legend.key.width = unit(0.5, \"line\"),\n      text = element_text(size = 5)\n    )\n}\n\n\nmy_caption=c(\"data: Austrian Parliament, Liste gemäß § 9 Bezügebegrenzungs-BVG, 2020. \\nanalysis: Roland Schmidt | @zoowalk | https://werk.statt.codes\")\n```\n\n</details>\n\n# Data extraction\n\nAs so often, one of the main challenges to actually analyze available data is to 'liberate' the information of interest from the format in which they are provided. The Parliament's report comes as a pretty 'untidy' pdf with subheadings etc., a format hardly conducive for further analysis. Here's one MP's declaration from the report:\n\n![](list_example - Copy.PNG){width=\"100%\"}\n\nEssentially, the table provides four relevant pieces of information: *1) an income category*, which groups MPs' additional income (which is within the scope of the legal reporting obligations and in addition to their salary as an MP) according to their average monthly income in 2019;\n\nThe income categories are:\n\n```{r echo=FALSE}\ndata.frame(\n  category = c(1L, 2L, 3L, 4L, 5L),\n  income.bracket = c(\n    \"1-1,000\", \"1,001-3,500\",\n    \"3,501-7,000\", \"7,001-10,000\", \">10,000\")) %>% \n    gt() %>% \n  gt::cols_label(income.bracket=md(\"**income bracket (Euro)**\"),\n                 category=md(\"**category**\")) %>% \n  gt::cols_align(align=\"right\",\n                 columns = c(income.bracket))\n```\n\nAnd lists of **2) executive positions** in stock companies, private limited companies, foundations or saving banks held by each MP; **3) other activities** from which MPs generate income; and **4) honorary activities** which yield no income (but could potentially nevertheless lead to some conflict of interest).\n\nExtracting data from pdfs has been the topic of at least one of my previous posts (see [here](https://werk.statt.codes/post/bih-voting-behavior-of-mps-in-house-of-representatives/){target=\"_blank\"}), and again the primary tool for the job is the wonderful `pdftools` package. Rather than seeking to extract tables from the pdf (e.g. with `tabulizer` ), I convert the content of each page of the report to a long text string and subsequently extract the parts of interest by means of `stringr` and regex. However, as I'll explain below, this approach was only suited to do some part of the task at hand.\n\nLet's start by retrieving the raw text.\n\n```{r code_folding=\"Code: Extract text from pdfs\"}\nmy_path <- here::here(\"posts\", \"2020-07-21-attransperency\", \"BezBegrBVGPar9-NR.pdf\")\n\ndf_all <- pdftools::pdf_text(pdf = my_path) %>%\n  enframe(.,\n    name = NULL,\n    value = \"text_raw\"\n  ) %>%\n  mutate(text_raw = str_replace_all(text_raw, \"\\\\h+\", \" \"))\n```\n\nThe code above provides us with a tibble containing as many rows as the report has pages (186). The expression `str_replace_all(text_raw, \"\\\\h+\", \" \")` replaces all horizontal white space with a single space, but keeps line breaks (\\\\n and \\\\r). The latter will be needed at a later stage when it comes to identifying the location of data of interest and extract them.[^3]\n\n[^3]: I am grateful to the respondents to my pertaining question on [stackoverflow](https://stackoverflow.com/questions/62678640/stringr-remove-multiple-spaces-but-keep-linebreaks-n-r/62679016#62679016){target=\"_blank\"}\n\nEach row is one long string containing all the information from only one single page on an MP. However, note that the declarations of some MPs span over multiple pages, hence their data is contained in multiple strings. This is something we have to account for when crunching numbers during the actual analysis. Here one example for the data on one MP. Use the horizontal scrollbar to get an idea of the strings composition.\n\n```{r echo=FALSE, tidy=FALSE, R.options=list(width=10), code_folding=NULL}\nstringr::str_wrap(df_all$text_raw[1], 10)\n```\n\n## Get income category\n\nAs a first step, let's extract the name of the MPs and the income category from the raw strings obtained above. The code chunk below is the pertaining code, making use of `stringr` and `regex`. Note the `(?s)` term in the regex expressions. While `.` would match any pattern but not line breaks, the `(?s)` alters this limitation and forces `.` to match also `\\n` and `\\r`.[^4]\n\n[^4]: See [here](https://stackoverflow.com/questions/159118/how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression/45981809#45981809){target=\"_blank\"} for a very helpful answer on SO.\n\n\n```{r, code_folding=FALSE}\ndf_all <- df_all %>%\n  mutate(name = str_extract(text_raw, regex(\"(?<=Einkommenskategorie)(?s).*(?=für das Jahr)\", ignore_case = T)) %>%\n    str_remove(., \"\\\\(i\\\\)\") %>%\n    str_trim()) %>%\n  mutate(income_category_19_raw = str_extract(text_raw, regex(\"(?<=2019:\\\\s?)\\\\S\"))) %>% \n  mutate(income_category_19=case_when(income_category_19_raw==\"-\" ~ \"0\",\n  .default = income_category_19_raw))  %>%\n  # mutate(income_category_19=income_category_19_raw) %>%\n  replace_na(., list(income_category_19=\"missing\")) %>%\n  select(-income_category_19_raw)\n  \n```\n\n\n\nAs already highlighted, since the declarations of some MPs run over multiple pages and are hence included several times in the above output, we have to limit the result to one row per MP. This is what `distinct()` does in the code chunk below.\n\n```{r code_folding=FALSE}\ndf_income <- df_all %>%\n  select(name, income_category_19) %>%\n  distinct()\n\nnrow(df_all)\nnrow(df_income)\n```\n\n\n## Missing income data\n\nLet's have a first, quick look at the information obtained so far:\n\n```{r, code_folding=\"Code: Number of MPs per income bracket\"}\ntbl_income <- df_income %>% \n  count(income_category_19) %>% \n  gt() %>% \n  gt::cols_label(income_category_19=md(\"**income category**\"),\n                 n=md(\"**number of MPs**\")) \n```\n\n\n```{r echo=FALSE, code_folding=NULL}\ntbl_income\n```\n\nBefore digging into frequencies of the income categories etc, a note on the missing observations. In ten instances, MPs did not report their income for 2019. Here are the ten MPs with missing income data.\n\n```{r, code_folding=\"Code: MPs with with missing income data\"}\ndf_income_missing <- df_income %>% \n  filter(income_category_19==\"missing\") %>% \n  mutate(family_name=str_remove(name, \",.*$\") %>% \n           str_extract(., \"\\\\S*$\")) \n  \ntbl_missing <- df_income_missing %>% \n  select(name, income_category_19) %>% \n  gt() %>% \n  cols_label(income_category_19=md(\"**income bracket**\"),\n             name=md(\"**MP**\")) %>% \n  gt::cols_align(align=\"center\",\n                 columns = vars(income_category_19))\n```\n\n\n```{r echo=FALSE, code_folding=NULL}\ntbl_missing\n```\n\nOne possible explanation for missing income data could be that these MPs have joined parliament only after the reporting period, i.e. in 2020 (I mean, there couldn't be any other possibility, no?). To check this, we need to obtain the dates of each MP's entry to parliament. Initially, I expected that such data should be readily available, but I must have been looking at the wrong places... Anyway, never waste an opportunity to scrap data.\n\nThe website of the Austrian Parliament provides a list of all (current and previous) MPs. This list is provided in an xml format from which we can obtain the links to each MP's individual biographical page. From these bios, we can subsequently extract the data when MP's entered the parliament. Not a bad detour...or, as a saying in German goes, Umwege erhöhen die Ortskenntnisse...(something like 'detours increase your local knowledge'.)\n\n```{r include=FALSE}\n# readr::write_rds(df_mp_dates, path=here::here(\"posts\", \"2020-07-21-attransperency\", \"MP_dates.rds\"))\n\ndf_mp_dates <- readr::read_rds(file=here::here(\"posts\", \"2020-07-21-attransperency\", \"MP_dates.rds\"))\n```\n\n```{r eval=FALSE}\nlibrary(xml2)\nlibrary(rvest)\nlink <- \"https://www.parlament.gv.at/WWER/PARL/J1918/filter.psp?view=RSS&jsMode=&xdocumentUri=&filterJq=&view=&NRBR=ALLE&GP=XXVII&R_WF=FR&FR=ALLE&W=W&M=M&listeId=8&FBEZ=FW_008\"\n\n#parse info from parliament's website\ndata <- xml2::read_xml(link)\n\n#extract name of MPs\ndf_title <- data %>% \n  xml2::xml_find_all(\"//title\") %>% \n  html_text() %>% \n  enframe(., \n          name=\"id\",\n          value=\"title\")\n\n#extract link to bio\ndf_link <- data %>% \n  xml2::xml_find_all(\"//link\") %>% \n  html_text() %>% \n  enframe(., \n          name=\"id\",\n          value=\"link\")\n\n#combine both to one dataframe\ndf <- df_title %>% \n  left_join(., df_link,\n            by=\"id\")\n\n#remove non-MP relevant rows\ndf <- df %>% \n  filter(str_detect(link, \"PAD_\")) %>% \n  mutate(link=str_trim(link))\n\n#define function to extract MP's entry/exit dates from biography\nfn_get_dates <- function(x) {\n  read_html(x) %>% \n  html_nodes(xpath=\"/html/body/div[1]/div[5]/div[1]/div[1]/div[3]/div[2]/div[2]/ul[1]/li/div/text()[2]\") %>% \n  html_text()\n}\n\ndf\n\n#apply funciton to all links\ndf_mp_dates <- df %>%\n  mutate(mp_dates=map(link, ~fn_get_dates(.)))\n\n\n```\n\n```{r include=FALSE}\n#extract family name for subsequent merger with income data\ndf_mp_dates <- df_mp_dates %>% \n  mutate(family_name=str_trim(title) %>% \n           str_extract(., regex(\"^\\\\S*\")))\n\n#merge with MPs whose income data is missing\ndf_income_missing <- df_income_missing %>% \n  left_join(., df_mp_dates %>%\n              select(family_name, mp_dates),\n            by=c(\"family_name\"=\"family_name\")) %>% \n  select(name, mp_dates) %>% \n  mutate(mp_dates=unlist(mp_dates) %>% \n           str_remove(., regex(\"(?<=\\\\d{4}).*\")))\n\n```\n\n```{r echo=FALSE, code_folding=NULL}\ndf_income_missing %>% \n  gt() %>% \n  gt::cols_label(mp_dates=md(\"**entry date**\"),\n                 name=md(\"**MP**\"))\n```\n\nAnd indeed. From the result above, we see that all those MPs who haven't submitted any income information were not MPs in 2019 *for a full month* (this is the requirement stipulated in the pertaining regulation). Hence, for the subsequent analysis on income data, when can safely disregard these MPs.\n\n```{r echo=TRUE, code_folding=\"Code: Remove MPs joining outside of reporting period\"}\nnrow(df_income)\ndf_income <- df_income %>% \n  filter(!name %in% df_income_missing$name)\nnrow(df_income)\n```\n\n\n# MPs' gender\n\n```{r include=FALSE}\ngender_colors <- c(female=\"firebrick\", male=\"grey\", missing=\"#BEBEBE\") \n\ndf_income_categories <- tibble::tribble(\n  ~income_category_19, ~category_values, ~category_labels,\n                   0L,              \"0\",              \"0\",\n                   1L,        \"1-1,000\",             \">1\",\n                   2L,    \"1,001-3,500\",            \">1K\",\n                   3L,    \"3,501-7,000\",          \">3.5K\",\n                   4L,   \"7,001-10,000\",            \">7K\",\n                   5L,        \">10,000\",           \">10K\"\n  ) \n\nincome_categories <- df_income_categories %>% \n  select(1, 2) %>%\n  deframe()\n\n\nincome_categories_short <- df_income_categories %>% \n  mutate(income_label=paste0(\n    \"[\",income_category_19,\"]\",\n    \"\\n\",\n    category_labels, \"€\")) %>% \n  select(1, 4) %>%\n  deframe()\n\n```\n\nLet's have a gender-sensitive look at the income data. With the `gender`package we are able to infer with some acceptable margin of error MPs' gender from their first names. Names which were not (properly) recognized by the package I corrected manually in the code chunk below.\n\n```{r, code_folding=FALSE}\n#get a clean name, without any academic or prefessional titles\ndf_income <- df_income %>% \n  mutate(name_family=str_remove(name, \",.*$\") %>% \n           str_extract(., \"\\\\S*$\"),\n         .after=name) %>% \n  mutate(name_clean=name %>% str_remove(., regex(\",.*$\")) %>% \n           str_remove_all(., regex(\"\\\\S*\\\\.\")) %>% \n           str_remove_all(., regex(\"\\\\(.*\\\\)\")) %>% \n           str_trim()) \n\n\nlibrary(gender)\n#extract first name and apply gender function to it\ndf_income <- df_income %>% \n  mutate(first_name=str_extract(name_clean, regex(\"^\\\\S*\"))) %>% \n  mutate(name_gender=map(first_name, possibly(gender,\n                                              otherwise=\"missing\"))) \n\n# manually correct for some missing gender data\ndf_income<- df_income %>% \n  unnest_wider(name_gender,names_repair=\"universal\") %>% \n  rename(name=name...1) %>% \n  select(-contains(\"year\"), -contains(\"proportion\"), -ends_with(\"7\")) %>% \n  mutate(gender=case_when(str_detect(name, \"Brandstötter\")==TRUE ~ \"female\",\n                          str_detect(name, \"El-Nagashi\")==TRUE ~ \"female\",\n                          str_detect(name, \"Sibylle\")==TRUE ~ \"female\",\n                          str_detect(name, \"Himmelbauer\")~\"female\",\n                          str_detect(name, \"Karlheinz\")==TRUE ~ \"male\",\n                          str_detect(name, \"Jörg\")==TRUE ~ \"male\",\n                          str_detect(name, \"Volker\")==TRUE ~ \"male\",\n                          str_detect(name, \"Gertraud\")==TRUE ~ \"female\",\n                          str_detect(name, \"Nurten\")==TRUE ~ \"female\",\n                          str_detect(name, \"Süleyman\")==TRUE ~ \"male\",\n                          str_detect(name, \"Ribo\")==TRUE ~ \"female\",\n                          TRUE ~ as.character(gender)))\n```\n\n\n## Female share per income group\n\nWhat the subsequent analysis reveals is that the share of women per income category decreases the further we move up the income ladder. While there is almost gender parity in the income category 0, womens' shares decrease continuously up to category 4.\n\n\n```{r, code_folding=T}\ndf_gender <- df_income %>% \n  group_by(income_category_19, gender) %>% \n  summarise(n_obs=n()) %>% \n  mutate(n_rel_category=n_obs/sum(n_obs)) %>% \n  group_by(gender) %>% \n  mutate(n_gender=sum(n_obs)) %>% \n  ungroup() %>% \n  mutate(n_rel_gender=n_obs/n_gender)\n\npl_gender_category <- df_gender %>% \n  # filter(gender==\"female\") %>% \n  mutate(gender=fct_rev(gender)) %>% \n  ggplot()+\n  labs(title=glue(\"Austrian Nationalrat: Share of <span style  = color:{gender_colors['female']}>female</span> and <span style = color:{gender_colors['male']}>male</span> MPs per income category\"),\n       subtitle=str_wrap(\"Income: average monthly income from professional positions in addition to MPs' salary. Absolute number of female MPs in brackets. Only lower chamber. Data for 2019.\", 105),\n       y=\"[income category] average monthly income\",\n       caption=my_caption)+\n  geom_bar(aes(y=income_category_19,\n               x=n_obs,\n               fill=gender),\n           stat=\"identity\",\n           position=\"fill\")+\n  geom_text(data=. %>% filter(gender==\"female\"),\n            aes(y=income_category_19,\n                x=n_rel_category-0.01,\n                label=paste0(round(n_rel_category,2) %>% \n                  percent(scale=100),\n                  \"\\n(\",\n                  n_obs,\n                  \")\")),\n            color=\"white\",\n            lineheight=0.6,\n            hjust=1,\n            stat=\"identity\")+\n  geom_vline(xintercept = .5,\n             color=\"white\",\n             linetype=\"dashed\"\n             )+\n  scale_fill_manual(values=gender_colors)+\n  scale_x_continuous(label=scales::label_percent(),\n                     expand=expansion(mult=c(0, 0.05)))+\n  scale_y_discrete(labels=income_categories_short,\n                   expand=expansion(mult=c(0, 0)),\n                   position = \"left\")+\n  theme_post()+\n  theme(legend.position=\"none\",\n        plot.title=element_markdown(),\n        axis.title.x=element_blank(),\n        axis.title.y.left = element_text(angle = 90,\n                                         color=\"grey50\",\n                                         hjust=1),\n        axis.text.y.left = element_text(),\n        axis.text.y.right = element_blank(),\n        axis.title.y.right = element_blank(),\n        panel.grid.major.y  = element_blank())\n\n```\n\n```{r echo=FALSE, fig.height=6, fig.width=10, code_folding=NULL}\npl_gender_category\n\n```\n\n## Share of income groups per gender group\n\nAnother gender sensitive perspective is to look at the distribution of the MPs across income categories within each gender group (in contrast to within each income group as in the previous graph). The graph highlights the difference between female and male MPs in terms of the income categories. While the distribution for female MPs is skewed towards lower income categories, that for male MPs is more concentrated on income category 2 and 3. Furthermore, only 4.4 % of all female MPs have additional incomes falling into the two highest categories, 4 and 5. In contrast, 19 % of all male MPs have income from these categories.\n\n<details closed>\n\n<summary>Code: graph intra-gender distribution </summary>\n\n```{r, code_folding=F}\npl_gender_intra_dist <- df_gender %>% \n  ggplot()+\n  labs(title=\"Austrian Nationalrat: Distribution of MPs over income groups per gender\",\n       subtitle=str_wrap(\"Income: average monthly income from professional positions in addition to MPs' salary. Absolute number of MPs in brackets. Only lower chamber. Data for 2019.\", 105),\n       x=\"[income category] average monthly income\",\n       caption=my_caption)+\n  geom_bar(aes(x=income_category_19,\n               y=n_rel_gender,\n               fill=gender),\n           stat=\"identity\")+\n  geom_text(aes(x=income_category_19,\n                y=n_rel_gender+0.02,\n                label=paste0(percent(n_rel_gender, accuracy = 0.1),\n                             \"\\n\",\n                             \"(\", n_obs, \")\")),\n            lineheight=0.7,\n            stat=\"identity\")+\n  scale_fill_manual(values=gender_colors, \n                    na.value = \"grey30\")+\n  scale_x_discrete(labels=income_categories_short)+\n  scale_y_continuous(label=scales::label_percent(accuracy=1),\n                     expand=expansion(mult=c(0, 0.1)))+\n  facet_wrap(vars(gender))+\n  theme_post()+\n  theme(legend.position = \"none\",\n        axis.title.x = element_text(angle = 0,\n                                         color=\"grey50\",\n                                         hjust=1),)\n```\n\n</details>\n\n```{r echo=FALSE, code_folding=NULL}\npl_gender_intra_dist\n```\n\n# Party affiliation\n## Get MPs' party membership\n\nAs the next step to facilitate the analysis of the data, let's add MPs' party affiliation. I do this by importing the pertaining data from wikipedia's entry on Austria's current MP (the parliament's website was simply to messy for my liking). Here, the `rvest` package is our friend. Once the data on MP membership is retrieved, I merge it with MPs' income/transparency data. The key/identifier to merge both sets of data is an MP's name. To make this work, I had first to remove all academic/professional titles (it's Austria after all) and harmonize the sequence of first and family names.\n\n```{r, code_folding=\"Code: Get party affiliation\"}\nwiki_link <- \"https://de.wikipedia.org/wiki/Liste_der_Abgeordneten_zum_%C3%96sterreichischen_Nationalrat_(XXVII._Gesetzgebungsperiode)\"\n\nlibrary(rvest)\n\ndf_nr <- wiki_link %>% \n  read_html() %>% \n  html_nodes(\"table\") %>% \n  html_table(fill=TRUE) %>% \n  .[[1]] %>% \n  janitor::remove_empty(., which=c(\"cols\")) %>% \n  janitor::clean_names() %>% \n  as_tibble()\n\ndf_nr <- df_nr %>% \n  mutate(name_family=str_extract(name, regex(\"^\\\\S*\"))) %>% \n  select(contains(\"name\"), party=wahl_partei) %>% \n  mutate(name_first=str_remove(name, regex(\"\\\\S*\"))) %>% \n  mutate(name_clean=paste(name_first, name_family) %>% \n           str_trim() %>% str_squish()) %>% \n  mutate(name_clean=case_when(str_detect(name, \"Künsberg\")==TRUE ~ \"Martina Künsberg Sarre\",\n                               TRUE ~ as.character(name_clean))) \n  \n\n#manually adjust inconsistently spelled names\ndf_income <- df_income %>% \n  mutate(name_clean=case_when(str_detect(name, \"Nurten\")==TRUE ~ \"Nurten Yilmaz\",\n                               # str_detect(name, \"Künsberg\")==TRUE ~ \" Martina Künsberg Sarre\",\n                              str_detect(name, \"Herr\")==TRUE ~ \"Julia Herr\",\n                              str_detect(name, \"Schellhorn\")==TRUE ~ \"Sepp Schellhorn\",\n                              str_detect(name, \"Lercher\")==TRUE ~ \"Max Lercher\",\n                              str_detect(name, \"Niss\")==TRUE ~ \"Maria Niss\",\n                              TRUE ~ as.character(name_clean)))\n\ndf_income <- df_income %>% \n  left_join(., df_nr %>% \n              select(name_clean, party),\n            by=c(\"name_clean\"=\"name_clean\")) %>% \n  mutate(party=case_when(str_detect(name, \"Strache\")==T ~ \"independent\",\n                         TRUE ~ as.character(party))) %>% \n  ungroup()\n\ndf_income <- df_income %>% \n  mutate(party=fct_infreq(party))\n\n\n\n```\n\n\nBelow the result with all MPs, their party affiliation, and income data.\n\n```{r echo=FALSE, code_folding=NULL}\ndatatable(df_income %>% select(name, party, gender, income_category_19),\n          colnames=c(\"MP name\"=\"name\", \"income category\"=\"income_category_19\"),\n          filter=\"top\",\n          options=list(pageLength=10,\n                       columnDefs = list(list(className = 'dt-center', targets = 1:3,\n                                         searchable=TRUE))),\n          rownames = FALSE)\n```\n\n```{r include=FALSE}\nparty_colors <- c(FPÖ = \"#005DA8\", NEOS = \"#EA5290\", ÖVP = \"#5DC2CC\", SPÖ = \"#FC0204\", GRÜNE = \"#A3C630\",\n                  independent=\"grey80\")\n\n```\n\n## MPs' income category by party\n\nWith data on each MP's income category and party membership available, let's aggregate the data by parties. The graph below show the distribution of MPs over income categories per party in relative (and absolute) terms.\n\n```{r, code_folding=\"Code: plots on income categories\"}\ndf_agg <- df_income %>% \n  ungroup() %>%\n  mutate(income_category_19_fac=as_factor(income_category_19) %>% \n           fct_inseq()) %>% \n  mutate(party=fct_infreq(party)) %>% \n  group_by(income_category_19, party, .drop = F) %>% \n  summarise(n_obs=n()) %>% \n  group_by(party) %>% \n  mutate(n_obs_total=sum(n_obs)) %>% \n  mutate(n_obs_rel=n_obs/n_obs_total)\n\npl_rel <- df_agg %>% \n  ggplot()+\n  labs(title=\"Austrian Nationalrat: Relative number of MPs per income category and party\",\n    subtitle=str_wrap(\"Percentages are shares of each party's total number of members. Absolute numbers in brackets. Lower chamber only (Nationalrat). Data for 2019.\", 105),\n    x=\"[income category] average monthly income\",\n    caption=my_caption)+\n  geom_label(data=. %>% filter(n_obs_rel >0),\n            aes(x=party,\n                y=n_obs_rel+.3,\n                family=\"Roboto Condensed\",\n                group=party,\n                label=paste0(scales::percent(n_obs_rel,\n                                      accuracy=0.1),\n                            \"\\n\",\n                            \"(\", n_obs, \")\")\n                ),\n            fill=plot_bg_color,\n            label.size=0,\n            label.padding = unit(0.1, \"lines\"),\n            lineheight=0.7,\n            family=\"Roboto Condensed\",\n            position=position_dodge2(width = 1))+\n    geom_bar(aes(x=party,\n               y=n_obs_rel,\n               group=income_category_19,\n               fill=party),\n           position=position_dodge2(),\n           stat=\"identity\"\n           )+\n  scale_fill_manual(values=party_colors)+\n  scale_x_discrete(labels=abbreviate)+\n  scale_y_continuous(label=scales::label_percent(),\n                     # limits = c(0, 1.15),\n                     expand=expansion(mult=c(0, 0.15)))+\n  lemon::facet_rep_wrap(vars(income_category_19),                        labeller=labeller(income_category_19=map_chr(income_categories_short, ~str_remove_all(., regex(\"\\\\]|\\\\[\"))) %>% \n                                                                                             map_chr(., ~str_replace(., regex(\"\\\\\\n\"), \": \")) %>%\n                                                                                             map_chr(., ~paste0(\"Income category \", .))),\n                        ncol=2,\n                        repeat.tick.labels = TRUE)+\n  theme_post()+\n  theme(legend.position=\"none\",\n        axis.title.x = element_blank())\n```\n\n```{r}\n#| echo: false\n#| code-fold: false\n#| column: page-right\n\npl_rel\n```\n\nThe ÖVP features the smallest share of MPs with no additional income (income category 0, only 6.2 %) followed by the FPÖ (though with a substantially higher share of 26.7 %). In contrast, Greens and Neos feature with 45.5 % and 40 % the highest share of MPs in in this category (leaving aside, Philippa Strache, the one independent MP with no additional income). The ÖVP features the highest absolute numbers in income categories 3, 4 and 5. In contrast, there are no Green MPs with an income falling into category 4 or 5. Similarly, there is also not a single MP from the SPÖ with an income from category 5. What's noteworthy with Neos is that they feature a comparably large share of MPs from income category 0, but also the largest relative number of MPs from the highest income category (13.3 %; equal with that of the FPÖ).\n\n# MPs' further jobs\n\nThe subsequent part of the analysis will focus on MPs' additional professional positions, as provided by the transparency report. As outlined in the introduction, it provides details on MPs' additional 1) executive positions in stock companies, private limited companies, foundations or saving banks; this section further distinguishes between those executive positions which are remunerated and those which aren't. 2) other professional activities from which MPs generate income; and 3) (unpaid) honorary activities.\n\n## Extracting data\n\nExtracting MPs' additional professional positions from the pdfs has been somewhat challenging. Initially - I was actually about to post the blog - I thought I could retrieve the data again with the `pdf_text` function as done above. However, when double checking some of the obtained results with the original pdf, I had to realize that some of my obtained numbers were inflated. After some digging and more digging, it turned out that the error originated from professional positions with names running over more than one line, i.e. which have a line break. Since I initially had counted the number of lines of positions to get the number of positions, some positions were counted multiple times. This problem arose since I was not able to distinguish between line breaks within cells (position with a long name) and those line breaks which indicated a new cell/row in the pdf's table (different professional position).\n\nThe answer to this challenge is provided by the `pdf_data` function, also from the `pdftools` package. As the output below shows, the function provides you with x and y coordinates for the actual, physical location of each textbox (for details see [here](https://ropensci.org/technotes/2018/12/14/pdftools-20/){target=\"_blank\"}).\n\n```{r echo=FALSE, code_folding=NULL}\npdf_file <- pdftools::pdf_data(pdf = my_path) \ndatatable(pdf_file[[8]],\n          options=list(pageLength=10,\n                       columnDefs = list(list(className = 'dt-center', targets = 0:4)),\n                       list(className='dt_left', targets=5)),\n          rownames=FALSE)\n```\n\nTaking a closer look at the rows in the results, I noticed that the difference in y values for linebreaks within a cell (long position name) is different than that between cells (different position). While 'normal' line breaks result in a y value change of 11, new cells result in a higher change of the y value. Hence, the difference in y values can be used as an indicator for a new cell and hence a different professional position.\n\nTo make use of this difference, I first calculate the difference of y values per row (`line_diff`), and subsequently and indicator which turns 1 if the y difference exceeds 11 (`row_jump`). Finally, I accumulate the value of the indicator to get an indicator for each row (`row_indicator`). For an example see the output below.\n\n```{r, code_folding=\"Code: identifying new positions\"}\ndf_linebreaks <- pdf_file[[8]] %>%\n  select(y, text) %>% \n    arrange(y) %>%\n    mutate(line_diff = y - dplyr::lag(y, default = 0)) %>%\n    mutate(row_jump = case_when(\n      line_diff > 11 ~ 1,\n      TRUE ~ 0\n    )) %>%\n    mutate(row_indicator = cumsum(row_jump)) \n```\n\n```{r echo=FALSE, code_folding=NULL}\n# datatable(df_linebreaks,\n#           options=list(pageLength=10,\n#                        columnDefs = list(list(className = 'dt-center', targets = \"all\"))),\n#           rownames=FALSE)\n```\n\n```{r}\n#| echo: false\nlibrary(reactable)\nlibrary(reactablefmtr)\ndf_linebreaks %>%\nreactable(, theme=nytimes())\n```\n\n\nIn the next step, I group the data by the `row_indicator` and combine the different text parts with the same row indicator into one string. As a result, we get a dataframe where each row contains one row of the table (including those parts after the line break). Hooray!\n\n```{r paged.print=TRUE, code_folding=\"Code: Table with one row per position\"}\ndf_rows <- df_linebreaks %>% \n  group_by(row_indicator) %>%\n    summarise(text_combined = paste(text, collapse = \" \")) %>%\n    mutate(text_combined = text_combined %>% str_trim() %>% str_squish())\n```\n\n```{r, ech=F, code_folding=NULL}\ndf_rows\n```\n\nFrom this new dataframe we have to filter out those rows which contain the different professional positions we are interested in. To do this, I first extract the row number of those rows which contain the subheading of each nested table (on executive, other, and honorary positions). With row number values of these rows, I can subsequently filter out those rows which are located between the headings (= professional positions).\n\n```{r, code_folding=\"Code: row numbers of sub-headings\"}\n# headings\nheading_executive <- df_rows %>%\n    filter(str_detect(text_combined, regex(\"Leitende Stellung in\", ignore_case = T))) %>%\n    pull(row_indicator)\n\nheading_other <- df_rows %>%\n    filter(str_detect(text_combined, regex(\"SONSTIGE TÄTIGKEITEN\", ignore_case = T))) %>%\n    pull(row_indicator)\n\nheading_honorary <- df_rows %>%\n    filter(str_detect(text_combined, regex(\"ehrenamtlich\", ignore_case = T))) %>%\n    pull(row_indicator)\n  \nheading_executive\nheading_other\nheading_honorary\n```\n\n## Putting it all into a function\n\nI put all the above outlined (and subsequent) steps into a function which provides me with the number of positions per category for each MP. Have a look in the code chunk below. In a sense, it's the key element of the overall analysis.\n\n```{r, code_folding=\"Code: Function to extract positions\"}\nfn_get_positions <- function(x) {\n  d <- x %>%\n    arrange(y) %>%\n    mutate(line_diff = y - dplyr::lag(y, default = 0)) %>%\n    mutate(row_jump = case_when(\n      line_diff > 11 ~ 1,\n      TRUE ~ 0\n    )) %>%\n    mutate(row_indicator = cumsum(row_jump)) %>%\n    group_by(row_indicator) %>%\n    summarise(text_combined = paste(text, collapse = \" \")) %>%\n    mutate(text_combined = text_combined %>% str_trim() %>% str_squish())\n\n  # headings\n  heading_executive <- d %>%\n    filter(str_detect(text_combined, regex(\"Leitende Stellung in\", ignore_case = T))) %>%\n    pull(row_indicator)\n\n  heading_other <- d %>%\n    filter(str_detect(text_combined, regex(\"SONSTIGE TÄTIGKEITEN\", ignore_case = T))) %>%\n    pull(row_indicator)\n\n  heading_honorary <- d %>%\n    filter(str_detect(text_combined, regex(\"ehrenamtlich\", ignore_case = T))) %>%\n    pull(row_indicator)\n\n  # executive position\n  if (length(heading_executive)!=0 & length(heading_other!=0)) {\n    df_executive <- d %>%\n      filter(!str_detect(text_combined, regex(\"Rechtsträger Leitende Stellung\"))) %>%\n      filter(row_indicator > heading_executive) %>%\n      filter(row_indicator < heading_other) %>%\n      select(-row_indicator)\n\n    n_executive <- ifelse(df_executive %>%\n      filter(str_detect(text_combined, regex(\"^keine$\"))) %>%\n      nrow() == 0,\n    nrow(df_executive),\n    0\n    )\n  } else {\n    df_executive <- tibble(text_combined = NA)\n    n_executive <- NA\n  }\n\n  # non-remunerated positions\n  n_executive_non_remunerated <- df_executive %>% \n    filter(str_detect(text_combined, regex(\"\\\\*\"))) %>% \n    nrow()\n  \n  # other\n\n  if (length(heading_other)!=0 & length(heading_honorary)!=0) {\n    df_other <- d %>%\n      filter(!str_detect(text_combined, regex(\"Dienstgeber/Rechtsträger/\"))) %>%\n      filter(row_indicator > heading_other) %>%\n      filter(row_indicator < heading_honorary) %>%\n      select(-row_indicator)\n\n    n_other <- ifelse(df_other %>%\n      filter(str_detect(text_combined, regex(\"^keine$\"))) %>%\n      nrow() == 0,\n    nrow(df_other),\n    0\n    )\n  } else {\n    df_other <- tibble(text_combined = NA)\n    n_other <- NA\n  }\n\n  # honorary\n  if (length(heading_honorary!=0)) {\n    df_honorary <- d %>%\n      filter(!str_detect(text_combined, regex(\"Rechtsträger\"))) %>%\n      filter(!str_detect(text_combined, regex(\"\\\\(i\\\\) Näheres bei\\\\: Informationen\"))) %>%\n      filter(row_indicator > heading_honorary) %>%\n      select(-row_indicator)\n\n    n_honorary <- ifelse(df_honorary %>%\n      filter(str_detect(text_combined, regex(\"^keine$\"))) %>%\n      nrow() == 0,\n    nrow(df_honorary),\n    0\n    )\n  } else {\n    df_honorary <- tibble(text_combined = NA)\n    n_honorary <- NA\n  }\n\n  # combine retreived info\n  df <- tibble(\n    executive_positions = list(df_executive),\n    executive_n = n_executive,\n    executive_non_remunerated_n=n_executive_non_remunerated,\n    other_positions = list(df_other),\n    other_n = n_other,\n    honorary_positions = list(df_honorary),\n    honorary_n = n_honorary\n  )\n  df\n}\n\n```\n\nThis function is applied to our previous results of the `pdf_data` function. At the end, I combine these results with MPs' names and aggregate those reports of MPs which run over multiple pages. Et voila! You can use the arrows to sort the table and get e.g the top-10 MPs as to their number of executive positions.\n\n```{r, code_folding=\"Code: Apply function\"}\ndf_data <- pdf_file %>%\n  map_dfr(., fn_get_positions)\n\ndf_positions <- bind_cols(df_all, df_data)\n\n#rowwise & c_across to calculate rowwise sums\ndf_count <- df_positions %>% \n  group_by(name) %>% \n  summarize(across(ends_with(\"_n\"), \\(x) sum(x, na.rm=T))) %>% \n  rowwise() %>% \n  mutate(total_n=sum(c_across(ends_with(\"_n\")&!contains(\"remunerated\")), na.rm=T))\n```\n\n\n```{r echo=FALSE, code_folding=NULL, eval=F, include=F}\ndatatable(df_count,\n          colnames=c(\"MP name\"=\"name\",\n                     \"# executive pos (total)\"=\"executive_n\",\n                     \"# executive pos not remunerated\"=\"executive_non_remunerated_n\",\n                     \"# other pos\"=\"other_n\",\n                     \"# honorary pos\"=\"honorary_n\",\n                     \"total # pos\" = \"total_n\"),\n          options=list(pageLength=10,\n                       columnDefs = list(list(className = 'dt-center', targets = \"all\"))),\n          rownames=FALSE)\n```\n\n```{r}\n#| code-fold: true\n\ndf_count %>%\nreactable(.,\ncolumns = list(\n  name=colDef(name=\"MP name\"),\n  executive_n=colDef(name=\"# executive pos (total)\"),\n  executive_non_remunerated_n=colDef(name=\"# executive pos not remunerated\"),\n  honorary_n=colDef(name=\"# honorary pos\"),\n  total_n=colDef(name=\"total # pos\")\n  ),\n  theme=nytimes()\n)\n```\n\n\nNote that the table comprises 183 MPs, hence also includes those MPs which were not obliged to submit income data (see above, missing data).\n\n```{r include=FALSE}\ndf_count2 <- df_count %>% \n    mutate(name_clean=name %>% str_remove(., regex(\",.*$\")) %>% \n           str_remove_all(., regex(\"\\\\S*\\\\.\")) %>% \n           str_remove_all(., regex(\"\\\\(.*\\\\)\")) %>% \n           str_trim()) %>% \n    mutate(first_name=str_extract(name_clean, regex(\"^\\\\S*\"))) %>% \n    mutate(name_gender=map(first_name, possibly(gender,\n                                                otherwise=\"missing\"))) %>% \n  unnest_wider(name_gender, names_repair=\"universal\") %>% \n  rename(name=name...1) %>% \n  select(-contains(\"year\"), -contains(\"proportion\"), -ends_with(\"7\")) %>% \n  mutate(gender=case_when(str_detect(name, \"Brandstötter\")==TRUE ~ \"female\",\n                          str_detect(name, \"El-Nagashi\")==TRUE ~ \"female\",\n                          str_detect(name, \"Sibylle\")==TRUE ~ \"female\",\n                          str_detect(name, \"Himmelbauer\")~\"female\",\n                          str_detect(name, \"Karlheinz\")==TRUE ~ \"male\",\n                          str_detect(name, \"Jörg\")==TRUE ~ \"male\",\n                          str_detect(name, \"Volker\")==TRUE ~ \"male\",\n                          str_detect(name, \"Gertraud\")==TRUE ~ \"female\",\n                          str_detect(name, \"Nurten\")==TRUE ~ \"female\",\n                          str_detect(name, \"Süleyman\")==TRUE ~ \"female\",\n                          str_detect(name, \"Ribo\")==TRUE ~ \"female\",\n                          TRUE ~ as.character(gender))) %>% \n   mutate(name_clean=case_when(str_detect(name, \"Nurten\")==TRUE ~ \"Nurten Yilmaz\",\n                              str_detect(name, \"Herr\")==TRUE ~ \"Julia Herr\",\n                              str_detect(name, \"Schellhorn\")==TRUE ~ \"Sepp Schellhorn\",\n                              str_detect(name, \"Lercher\")==TRUE ~ \"Max Lercher\",\n                              str_detect(name, \"Niss\")==TRUE ~ \"Maria Niss\",\n                              TRUE ~ as.character(name_clean))) %>% \n  left_join(., df_nr %>% \n              select(name_clean, party),\n            by=c(\"name_clean\"=\"name_clean\")) %>%\n  mutate(party=case_when(str_detect(name, \"Strache\")==T ~ \"independent\",\n                         TRUE ~ as.character(party)))\n\ndf_position_long <- df_count2 %>% \n  select(name_clean, party, gender, ends_with(\"_n\")) %>% \n  pivot_longer(cols=ends_with(\"_n\"), \n               names_to=\"position\",\n               values_to=\"number\") %>% \n  mutate(party=fct_infreq(party))\n```\n\n## Paid positions and income category\n\nLet's have a look at MPs' number of paid positions and income category.\n\nPaid are the positions stated in the category 'other positions' and 'executive position'. As for the latter, however, the list also includes unpaid executive positions which are marked with an asterisk (\\*). Hence these positions have to be removed when calculating the total number of paid positions. For details see [below](#unpaid_executive).\n\nHover over the points in the plot below to get details on each individual MP. Note that the points are located randomly *within* each square to avoid overplotting.\n\n\n```{r, code_folding=\"Code: Number of paid positions and income category\"}\ndf_income_positions <- df_count2 %>% \n  left_join(., df_income %>% select(gender, income_category_19, name),\n            by=\"name\") %>% \n  select(name_clean, name, contains(\"executive\"), contains(\"other\"), party, income_category_19) %>% \n  mutate(positions_paid=(executive_n-executive_non_remunerated_n)+other_n)\n\ndf_income_positions <- df_income_positions %>% \n  filter(income_category_19!=\"missing\") %>% \n  mutate(across(.cols=c(positions_paid, income_category_19), list(fct=~as_factor(.) %>% fct_inseq)))\n  \nincome.key <- levels(factor(df_income_positions$income_category_19))\nposition.key <- seq(0, max(df_income_positions$positions_paid), 1) %>% \n  as.character()\n  \npl_income_positions <- df_income_positions %>% \n  mutate(income_category_19_fct=fct_rev(income_category_19_fct)) %>% \n  mutate(positions_paid_fct=fct_expand(positions_paid_fct, position.key) %>% \n           fct_inseq()) %>% \n  mutate(party=fct_infreq(party)) %>% \n  ggplot()+\n  labs(x=\"number of paid positions\",\n       y=\"[income category] average monthly income\",\n       title=\"Austrian Nationalrat: MPs' number of paid positions and income category\",\n       subtitle=\"Members of lower chamber only (Nationalrat). Data for 2019.\\nMove mouse over dots to get info on MPs.\",\n       caption=my_caption)+\n  geom_jitter_interactive(aes(x=positions_paid,\n                                       y=income_category_19,\n                                       color=party,\n                                       tooltip=paste0(name_clean, \" \", party, \"\\n\", \"paid positions: \", positions_paid, \"\\n\", \"income category: \", income_category_19)))+\n  scale_color_manual(values=party_colors)+\n  scale_y_discrete(labels=income_categories_short)+\n  facet_grid(income_category_19_fct ~ positions_paid_fct,\n             drop=FALSE,\n             scales=\"free\",\n             switch=\"x\")+\n  theme_post()+\n  theme(panel.border = element_rect(color = \"black\", fill = NA, linewidth = .5),\n        panel.grid.major = element_blank(),\n        panel.spacing.y = unit(0, \"cm\"),\n        panel.spacing.x = unit(0, \"cm\"),\n        legend.position = \"bottom\",\n        legend.title=element_blank(),\n        legend.direction = \"horizontal\",\n        axis.text.x = element_blank(),\n        axis.title.y=element_text(color=\"grey50\",\n                                  hjust=1,\n                                  angle=90),\n        strip.text.x = element_text(hjust=0.5, color=\"grey50\",\n                                    face=\"plain\"),\n        strip.text.y = element_blank())+\n  guides(color=guide_legend(nrow=1))\n```\n\n\n```{r}\n#| column: page-right\ngirafe(ggobj = pl_income_positions)\n\n```\n\nOverall, there seems to be a positive association between the number of positions and income category. However, bear in mind that we do not know how much income is generate from each specific position. We only know about the sum and shouldn't be tempted to infer any average salaries per position. E.g. while Herbert Fuchs' four paid positions yield in sum an income of more than 10,000 Euros per average month (income category 5), it could be that the bulk of the income sum originates from one particularly position only. This is particularly relevant if we think about comparing MPs within the same income category but different number of paid positions.\n\nA further qualifying note on the lower end of the income scale: Note that there are five curious cases of MPs having at least one paid position, but zero additional income. How can that be? Let's look at these five cases more closely.\n\n```{r, code_folding=\"Code: MPs with no income but paid positions\"}\ndf_mp5 <- df_income_positions %>% \n  filter(income_category_19==0) %>% \n  filter(positions_paid>0) %>% \n  select(contains(\"name\"), party, executive_n, positions_paid) %>% \n  left_join(., df_positions %>% select(name, executive_positions, other_positions), by=c(\"name\"=\"name\")) %>% \n  pivot_longer(cols=c(contains(\"positions\"), -positions_paid),\n               names_to=\"positions\",\n               values_to=\"positions_name\") %>% \n  mutate(positions_chr=map(positions_name, deframe) %>% \n           map_chr(., ~paste(., collapse=\";\\n \"))) %>% \n  select(-positions_name) %>% \n  pivot_wider(id_cols=c(name, party),\n              names_from=positions,\n              values_from=positions_chr)\n\ntb_mp5 <- df_mp5 %>% \n  gt() %>% \n  tab_header(\n    title=md(\"**MPs with zero income, but paid positions**\")) %>% \n   tab_footnote(footnote = \"Honorary positions exclude since unpaid.\",\n    locations = cells_title(group=\"title\")) %>% \n  cols_label(\"name\"=md(\"**MP**\"),\n             \"party\"=md(\"**party**\"),\n             \"executive_positions\"=md(\"**executive positons**\"),\n             \"other_positions\"=md(\"**other positions**\"))\n\n```\n\n```{r echo=FALSE}\ntb_mp5\n```\n\nAs for Neos MPs' Hoyos-Trauttmansdorff and Scherak a look at the parliament's list reveals that their declaration features an additional note indicating that both assumed their position only from April 2020 onward. Hence, there was no pertaining income for the 2019 category. Scherak's second executive position ('Margaretha Lupac - Stiftung') is unpaid as indicated by the \\*. Hence, these two cases are clear.\n\nThe other three cases are less clear to me. Eva-Maria Himmelbauer has an executive position in the Cloudcompany and there is no \\* sign which would indicate that the position was without remuneration. What's furthermore noteworthy, if you look at the table above, it states 'Ablauf der Meldefrist: Geschäftsführerin 23.11.2019'. Remarkably, this text is not visible in the original pdf on the parliament's website. I have no idea why and how, but the used `pdf_data` function extracted also 'hidden' text from the pdf. Whether this text was a comment to an e.g. Excel cell or a hidden row/column, I don't know. But irrespective of this, there is nothing in the additional text what would suggest - at leat to me - that Himmelbauer did not receive at least for one month a salary during the reporting period. Similarly, Markus Koza and Meri Dioski had both paid positions for their own parities up until 31.10.2019. Nevertheless, this income was not reported as indicated by the income category 0.\n\nTo be clear, I have no reason to think that there is any malice etc. behind these inconsistencies, and I assume there is some formal, regulatory explanation which hasn't been made explicit in the parliament's list. If anyone has an answer to this I would be keen to hear it.\n\n## Share of MPs with at least one additional position\n\nTo move on and, to get some contrast between parties, the barplot below indicates the percentage of MPs per party which do have at least one additional professional position.\n\n```{r, code_folding=\">Code: MP share w at least one add. position\"}\ndf_bar_position <- df_position_long %>% \n  filter(!position %in% c(\"executive_non_remunerated_n\",\n                        \"total_n\")) %>% \n  group_by(party, position) %>% \n  summarize(n_zero=length(number[number==0]),\n            n_non_zero=length(number[number!=0])) %>% \n  ungroup() %>% \n  mutate(perc=n_non_zero/(n_non_zero+n_zero)) %>% \n  mutate(position=fct_relevel(position, \"honorary_n\", after = 2))\n\npl_bar_position <- df_bar_position %>% \n  ggplot()+\n  labs(title=\"Austrian Nationalrat: Percentage of MPs with at least one additional position per party\",\n       subtitle=str_wrap(\"Percentages are shares of each party's total number of members. Absolute numbers in brackets. Lower chamber only (Nationalrat). Data for 2019.\", 105),\n       caption=my_caption)+\n  geom_bar(aes(x=party,\n               y=perc,\n               fill=party),\n           stat=\"identity\")+\n  geom_text(aes(x=party,\n               y=perc,\n               group=party,\n               label=paste0(perc %>% scales::percent(),\n                           \"\\n\",\n                           \"(\", n_non_zero,\")\")),\n            nudge_y = 0.05,\n            lineheight=0.7,\n           stat=\"identity\")+\n  scale_fill_manual(values=party_colors)+\n  scale_color_manual(values=party_colors)+\n  scale_y_continuous(label=scales::label_percent(accuracy = 1),\n                     expand=expansion(mult=c(0, 0.15)),\n                     breaks=seq(0,1,.25))+\n  scale_x_discrete(label=abbreviate)+\n  facet_wrap(vars(position),\n             labeller = labeller(position=c(\"executive_n\"=\"executive functions\",\"other_n\"=\"other activities\",\n                                            \"honorary_n\"=\"honorary positions\")))+\n  theme_post()+\n  theme(legend.position=\"none\",\n        axis.title.x = element_blank())\n  \n```\n\n```{r}\n#| column: page-right\npl_bar_position\n```\n\nAs far as *executive positions* are concerned, the relative numbers of Neos stand out. More than half of Neos' MPs have an executive position. In absolute numbers, the ÖVP with 26 MPs leads in this category.\n\nWhen it comes to *honorary positions*, there is a considerable gap between the three larger parties (ÖVP, SPÖ, FPÖ) and the two smaller ones (Greens, Neos). One possible explanation (which I have not looked into though) could be that larger parties have more party affiliated associations in which their MPs take up honorary positions. Maybe, and I am purely speculating here, the number of honorary positions is a function of a party's institutional width.\n\n## Executive positions {#unpaid_executive}\n\nBelow I further disaggregate executive positions into those which entail a salary and those which don't. In the parliament's report, executive positions without salary were marked with an asterisk (\\*). When retrieving the data above, I already accounted for this difference (`str_detect(., \"\\\\*\")`). The graph below now shows the percentage of MPs per party without executive positions, those with at least one executive position without salary (and no position with salary), and those with at least one remunerated executive position.\n\n```{r, code_folding=\"Code: different types of executive positions\"}\ndf_executive <- df_count2 %>% \n    select(party, contains(\"executive\")) %>% \n    mutate(executive_remunerated_n=executive_n-executive_non_remunerated_n) %>% \n  group_by(party) %>% \n  summarize(executive_no=length(executive_n[executive_n==0]),\n    remunerated_yes=length(executive_remunerated_n[executive_remunerated_n>0]),\n    remunerated_no=length(executive_remunerated_n[executive_remunerated_n==0 &\n                            executive_n>0])) %>% \n  ungroup() %>% \n  rowwise() %>% \n  mutate(total=sum(c_across(where(is.numeric)), na.rm=T)) \n\npl_executive <- df_executive %>% \n  pivot_longer(cols=-c(party, total),\n               values_to=\"number\",\n               names_to=\"remunerated\") %>% \n  mutate(party=fct_reorder(party, total) %>% fct_rev) %>%   mutate(perc=number/total) %>% \n  mutate(remunerated=case_when(str_detect(remunerated, regex(\"executive_no\"))==TRUE ~\"% MPs without executive positions\",                               str_detect(remunerated, regex(\"remunerated_no\"))==TRUE ~ \"% MPs with non-remunerated executive positions\",\n                               str_detect(remunerated, regex( \"remunerated_yes\"))==TRUE ~ \"% MPs with remunerated executive positions\",\n                               TRUE ~ as.character(remunerated))) %>% \n  mutate(remunerated=fct_relevel(remunerated,\n                                 \"% MPs with non-remunerated executive positions\", after = 1L) %>% fct_rev) %>%\n  ggplot()+\n  labs(title=\"Austrian Nationalrat: Percentage of MPs with different executive positions per party\",\n       subtitle=str_wrap(\"Percentages are shares of each party's total number of members. Absolute numbers in brackets. Lower chamber only (Nationalrat). Data for 2019.\", 105),\n       caption=my_caption)+\n  geom_bar(aes(x=party,\n               y=perc,\n               fill=party),\n           position=position_dodge(),\n           stat=\"identity\")+\n  geom_text(aes(x=party,\n                y=perc+.05,\n                label=paste0(scales::percent(perc,\n                                             accuracy = 0.1),\n                             \"\\n\",\n                            \"(\", number,\")\"),\n                group=remunerated),\n            lineheight=0.7,\n            position=position_dodge2(width = 1),\n            stat=\"identity\")+\n  scale_y_continuous(labels=scales::label_percent(),\n                     expand=expansion(mult=c(0, .1)))+\n  scale_x_discrete(labels=abbreviate)+\n  scale_fill_manual(values=party_colors)+\n  theme_post()+\n  theme(legend.position=\"none\",\n        axis.title.x = element_blank())+\n  facet_wrap(vars(remunerated),\n             labeller=label_wrap_gen(width=30))\n\n```\n\n\n```{r echo=FALSE}\npl_executive\n```\n\nNote that there is only one MP from the Greens with a paid executive position. Also, there are only three Socialdemocrats in this category. Again, the ÖVP features most MPs with a paid executive position in absolute terms, and Neos in relative terms.\n\n## Parties in comparison (Boxplot)\n\nThe boxplot below might be a bit of an overkill, but it gives us a more detailed overview of MPs' additional positions per party. Each dot indicates the number of positions which one specific MP holds in one category of professional positions. In addition, the median, mean, max and minimum values for each party/position combination are provided. Note the comparably high median value of honorary positions among SPÖ MPs.\n\n<details closed>\n\n<summary>Code: boxplots</summary>\n\n```{r echo=TRUE, fig.height=7, code_folding=F}\ndf_position_labels <- df_position_long %>% \n  filter(!position %in% c(\"executive_non_remunerated_n\",\n                        \"total_n\")) %>% \n  group_by(party, position) %>% \n  mutate(party=fct_infreq(party)) %>% \n  summarise(label_median=median(number),\n            label_mean=mean(number),\n            label_max=max(number),\n            label_min=min(number))\n\npl_box <- df_position_long %>% \n  filter(!position %in% c(\"executive_non_remunerated_n\",\n                        \"total_n\")) %>% \n  mutate(party=fct_infreq(party)) %>% \n  ggplot()+\n  labs(caption=my_caption,\n       title=\"Austrian Nationalrat: Number of MPs' other professional positions per party\",\n       subtitle=\"Members of lower chamber only (Nationalrat); Data for 2019.\",\n       x=\"MP's number of positions\")+\n  geom_boxplot(aes(y=party,\n                  x=number,\n                  group=party,\n                  color=party),\n               orientation=\"y\",\n               outlier.shape=NA,\n               width=0.1\n               )+\n  geom_jitter(aes(y=party,\n                  x=number,\n                  group=party,\n                  colour=party),\n              alpha=.2,\n              orientation=\"y\",\n              height=0.1\n              )+\n  geom_label(data=df_position_labels,\n            aes(y=1.2,\n                x=0,\n                group=party,\n                label=paste(\"median:\", round(label_median, 2),\n                            # \"\\n\",\n                            \"mean:\", round(label_mean, 2),\n                            # \"\\n\",\n                            \"min:\", round(label_min, 2),\n                            # \"\\n\",\n                            \"max:\", round(label_max, 2)\n                            )),\n            fill=plot_bg_color,\n            label.padding = unit(0.2,\"line\"),\n            label.r=unit(0.2,\"line\"),\n            label.size = 0,\n            family=\"Roboto Condensed\",\n            size=3,\n            vjust=0,\n            hjust=0,\n            orientation=\"y\",\n            lineheight=0.5)+\n  scale_color_manual(values=party_colors)+\n  scale_x_continuous(expand=expansion(mult=c(0, .2)))+\n  scale_y_discrete(expand=expansion(mult=c(0, .3)),\n                   label=abbreviate)+\n  theme_post()+\n  theme(legend.position = \"none\",\n        panel.grid.major.x = element_line(color=\"gray30\"),\n        panel.grid.major.y = element_blank(),\n        strip.text.y = element_blank())+\n  lemon::facet_rep_grid(party~position,\n                        repeat.tick.labels = TRUE,\n                        scales = \"free_y\",\n                        labeller = labeller(position=c(\"executive_n\"=\"executive functions\",\"other_n\"=\"other activities\",\n\"honorary_n\"=\"honorary positions\")))\n\n```\n\n</details>\n\n```{r echo=FALSE, fig.height=7, fig.width=10, code_folding=NULL}\npl_box\n```\n\n# Wrap up\n\nSo this has become a rather length blog entry. I hope there's been something useful in it for you as well. Again, the emphasis has been largely on various steps in R to extract and subsequently analyze the data of interest. If there's anything you feel like following up, feel free to let me know.\n\n```{r, include=F, eval=F}\ndf_nr<- df_count %>% \n  left_join(., df_income %>% \n              select(-ends_with(\"6\"), -first_name),\n            by=c(\"name\"=\"name\")) %>% \n  select(name, name_clean, party, gender, income_category_19, contains(\"_n\"))\n\n#readr::write_excel_csv2(df_nr, path=here::here(\"posts\", \"2020-07-21-attransperency\", \"NR.csv\"))\n\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"left","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["lightbox"],"css":["../../styles.css"],"highlight-style":"github","toc":true,"toc-depth":3,"number-sections":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.321","author":[{"name":"Roland Schmidt","url":"https://werk.statt.codes"}],"editor":"visual","date-format":"D MMM YYYY","lightbox":{"match":"auto","desc-position":"bottom"},"theme":{"light":"litera"},"code-copy":true,"fontsize":"16px","toc-title":"Contents","toc-location":"left","fig-cap-location":"top","smooth-scroll":true,"title-block-banner":true,"license":"CC BY-NC","citation":true,"title":"Austrian Parliament: MPs transparency and conflict of interest report","description":"Analysis of Austria MP's transparency reports.","date":"07-21-2020","categories":["Austria","OCR","web scraping"],"image":"preview.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}