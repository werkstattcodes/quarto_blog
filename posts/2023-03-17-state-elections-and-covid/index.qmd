---
title: "State legislature elections and vaccination rates"
description: ""

date: 04-24-2023

categories:
  - Austria
  - COVID
  - R

reference-location: margin

draft: true
---


```{r}
library(tidyverse)
library(janitor)
library(sf)
library(patchwork)
library(reactable)
library(reactablefmtr)
library(ggpubr)
library(ggh4x)
library(biscale)
library(ggtext)
library(patchwork)
library(gghalves)
library(extrafont)
loadfonts(device = "win", quiet = T)
library(hrbrthemes)
library(ggiraph)


```

# CONTEXT

This post is a "quick" look at the most recent state-level elections in Austria, namely in Lower Austria, Carinthia, and Salzburg. More precisely, it's  a replication and extension of a graph [tweeted](https://twitter.com/laurenzennser/status/1620149912704024577){target="_blank"} by University of Vienna PolSci Prof Laurenz Ennser-Jedensastik in which he highlighted the rather remarkable relation between municipalities' rates of COVID vaccinations and the performance of the extreme-right Freedom Party (FPÖ) in Lower Austria.

This post adds little substantively new, but is rather an exercise in demonstrating

a\) how to extract electoral data from the rather intricate formats they were published in by the electoral authorities (@sec-getting-electoral-data).

b\) how to replicate the original graph highlighting the bivariate relationship between parties's vote share win/loss and COVID vaccination ratios on the municipal level (@sec-correlation). Upfront, to state the obvious, the results are not meant to imply any direct causality between vaccination rates and vote results, but are only highlighting mere correlations.

c\) how to visualize bivariate relationships on a map with the {biscale} package (@sec-biscale); and

d\) a few smaller side kicks along the way, including an alternative form of visualization with a combination of dot- and box-plots (@sec-dotplots).
<br>
<br>

# GETTING ELECTORAL DATA {#sec-getting-electoral-data}

Obtaining electoral data is not a big thing, as it should be. Getting them in a format, which is amenable to further analysis, e.g. in R, is another story. While there certainly has been some progress regarding Open Data, nevertheless, quite frequently, a considerable amount of data wrangling is necessary.

## Lower Austria

With the earlier elections in Lower Austria, the results came [inter alia](https://www.noe.gv.at/wahlen/L20231/Download.html){target="_blank"} as a standard xlsx file, however, with these column headers:

![](img\noe_results.PNG)

Below the necessary steps to eventually obtain a tidy dataframe. The [\`janitor\` package](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html%7Btarget=%22_blank%22%7D) once again turns out to be a very helpful tool.

```{r}
#| code-summary: "Code: Get results for Lower Austria"
#| code-fold: true
res_noe <- readxl::read_xls(path=here::here("posts","2023-03-17-state-elections-and-covid","data", "noe_lw23.xls"))

#get party names
vec_parties_noe <- res_noe %>% 
  slice(2) %>% 
  unlist(use.names=F) %>% 
  na.omit() %>% as.character()

#take body table
df_res_noe_clean <- res_noe %>% 
  janitor::find_header()

#make row number 3 auxiliary column names
df_res_noe_clean <- res_noe %>% 
  janitor::row_to_names(., row_number=3, remove_rows_above = T) %>% 
  clean_names() %>% 
  pivot_longer(.,cols=matches("stimmen|ant_|diff_"))

#Assign party names to columns
df_res_noe_clean <- df_res_noe_clean %>% 
  mutate(party=case_when(
    str_detect(name, regex("^Stimmen$")) ~ vec_parties_noe[[1]],
    str_detect(name, regex("^ant_percent$")) ~ vec_parties_noe[[1]],
    str_detect(name, regex("^diff_percent$")) ~ vec_parties_noe[[1]],
    str_detect(name, regex("_2$")) ~ vec_parties_noe[[2]],
    str_detect(name, regex("_3$")) ~ vec_parties_noe[[3]],
    str_detect(name, regex("_4$")) ~ vec_parties_noe[[4]],
    str_detect(name, regex("_5$")) ~ vec_parties_noe[[5]],
    str_detect(name, regex("_6$")) ~ vec_parties_noe[[6]],
    str_detect(name, regex("_7$")) ~ vec_parties_noe[[7]],
    str_detect(name, regex("_8$")) ~ vec_parties_noe[[8]],
    .default = NA
  ))

#Keep only municipalities
df_res_noe_municip <- df_res_noe_clean %>% 
  filter(str_detect(kenn_nr, regex("\\d{5}"))) %>% 
  select(kenn_nr, bezeichnung, name, value, party) %>% 
  filter(str_detect(name, regex("^diff_percent"))) %>% 
  mutate(diff_percent=as.numeric(value)) %>% 
  select(-name, -value)

#remove municipalities where a party did not run
df_res_noe_municip <- df_res_noe_municip %>%
filter(!is.na(diff_percent))

```

And with this we obtained a cleaned version of the election results for Lower Austria.
```{r}
#| include: false
#| eval: false
#check
n_distinct(df_res_noe_municip$kenn_nr) #573 OK

library(visdat)
visdat::vis_dat(df_res_noe_municip, facet=party)
```

```{r}
#| code-summary: "Code: Table results Lower Austria"
#| code-fold: true

df_res_noe_municip %>% 
  reactable(
    compact = TRUE, 
    filterable=T,
    defaultPageSize = 5, 
    theme = fivethirtyeight()
  ) %>%
  add_title(title = "Election Results Lower Austria 2023", font_size = 15) %>% 
  add_subtitle(subtitle = "Only municipal level, mail votes not included.", font_size=12)
```

## Carinthia

Carinthia's election results are published on a dedicated [website](https://www.ktn.gv.at/wahlen/ltwahl2023%7Btaget=%22_blank%22%7D){target="_blank"} by the state authorities. As you can see, the main page comprises a left-hand panel with links to each of the municipal results (and other categories). In turn, each of these municipal sub-pages contains a table with election results, the data in which I am actually interested in.

![Screenshot: Website of Election Results Carintia](img/carinthia_results.png)

To collect these data, let's take the following steps:

1\) From the left-hand panel on the overview page, extract all links leading to municipal subpages. The pertaining css-selector targets html elements with the id 'gemeinde'. Since this selector also captures aggregate categories for wider electoral districts which we do not want, they have to be removed. Conveniently, they are all spelled in capital letters, what makes it easy to match them via a regular expression and filter them out.

```{r}
#| code-summary: "Code: Get links to sub/municipality-pages with results."
#| code-fold: true

link_overview <- "https://www.ktn.gv.at/wahlen/ltwahl2023"

main <- rvest::session(link_overview)

#get links
res_links <- main %>% xml2::read_html() %>% 
  rvest::html_elements("#gemeinde a") %>% 
  rvest::html_attr("href")

#get names
res_names <- main %>% xml2::read_html() %>% 
  rvest::html_elements("#gemeinde a") %>% 
  rvest::html_text()

#combine links and names to a tibble
df_res <- tibble(links=res_links, names=res_names)

df_mun <- df_res %>% 
  #remove aggregate categories which are spelled with capital letters
  filter(!str_detect(links, regex("[A-Z]"))) %>% 
  #complete links to get entire address
  mutate(link_complete=glue::glue("https://www.ktn.gv.at/wahlen/ltwahl2023/{links}"))
```

Here the first few rows of obtained dataframe with all sub-page links.

```{r}
#| echo: false
df_mun 
```

2\) With the links to all municipal pages now available, the next step is about extracting the table with the actual electoral data. To so, I define a function which is subsequently mapped to each subpage link. The css selector allowing us to capture the table is on each page class '.bausteinausw3_bo'.

```{r}
#| code-summary: "Code: Define  and apply function to extract election results from subpages"
#| code-fold: true

#define function
fn_get_res_municip <- function(link_municip) {
  
# link_municip <- "https://www.ktn.gv.at/wahlen/ltwahl2023/lt2023_20402.html"
  
#Extract table   
df_res_municip <- link_municip %>% 
  xml2::read_html() %>% 
  rvest::html_elements(".bausteinausw3_bo") %>% 
  rvest::html_table() %>% 
  .[[1]] 

#Filter the results    
df_res_municip %>% 
  janitor::clean_names() %>% 
  filter(!str_detect(partei, regex("^Partei$|Gesamt|Ungültig|Gültig"))) %>% 
  mutate(partei=str_remove(partei, regex("^.+?(?=[A-Z])"))) %>% 
  rename_with(., .fn=\(x) str_replace(x, "_2", "_perc"), .cols=ends_with("_2")) %>% 
  mutate(across(.cols=-partei, .fns=\(x) parse_number(x, locale=locale(decimal_mark=",")))) %>% 
  mutate(link_municip=link_municip) %>% 
  mutate(municip_id=str_extract(link_municip, regex("\\d+(?=\\.html$)")))

}  

#Map links to function
df_res_ktn_municip<- df_mun %>% 
  pull(link_complete) %>% 
  map(., .f=\(x) fn_get_res_municip(link_municip = x), .progress=T) %>% 
  purrr::list_rbind() 

#Remove parties which did not run in 2023
df_res_ktn_municip <- df_res_ktn_municip %>%
filter(!is.na(lt2023))


#Correct for NA in difference field
df_res_ktn_municip  <-  df_res_ktn_municip %>%
mutate(differenz_perc=case_when(
  is.na(differenz_perc) & !is.na(lt2023_perc) ~ lt2023_perc,
  .default = differenz_perc
))


```

```{r}
#| include: false
#| eval: false
d <- df_res_ktn_municip %>%
group_by(municip_id) %>%
summarise(sum_dif=sum(differenz_perc, na.rm=T))
```
Below, the obtained election results for Carinthia.
```{r}
#| code-fold: false
#| code-summary: "Code: Table election results Carinthia"
df_res_ktn_municip %>% 
select(municip_id, everything()) %>%
    reactable(.,
    columns = list(
      partei=colDef(width=70),
      differenz_perc=colDef(width=120),
      link_municip=colDef(
        html=T,
        cell=function(value) {
          htmltools::tags$a(href=value, targe="_blank", as.character("link"))
                  },
                  align = "center"
      )
    ),
    compact = TRUE, 
    filterable=T,
    defaultPageSize = 5, 
    theme = fivethirtyeight()
  ) %>%
  add_title(title = "Election Results Carinthia 2023", font_size = 15) %>% 
  add_subtitle(subtitle = "Only municipal level.", font_size=12) 
```

## Salzburg

Data for Salzburg are available at the State's official website. Again, with somewhat inconvenient headers. Additionally, to get the changes between the 2023 and preceding 2018 elections, both results have to be downloaded (xlsx files) and the differences calculated.

```{r}
#| code-summary: "Code: Get results for Salzburg 2018"
#| eval: true
df_res_sbg_18 <- readxl::read_xlsx(path=here::here("posts", "2023-03-17-state-elections-and-covid", "data", "sbg_TW-2018.xlsx"), 
sheet="Stimmen",
skip=3, col_types = "text") 

vec_col_names <- c(
  "code", "region", 
"eligible_total", "eligible_male",
"eligible_female", 
"votes_total_abs", "votes_total_rel", 
"votes_invalid_abs", "votes_invalid_rel", 
"votes_valid_abs", 
# "votes_valid_rel" ,
"oevp_abs", "oevp_rel",
"spoe_abs", "spoe_rel",
"greens_abs", "greens_rel",
"fpoe_abs", "fpoe_rel",
"fps_abs", "fps_rel",
"neos_abs", "neos_rel",
"kpoe_abs", "kpoe_rel",
"mayr_abs", "mayr_rel",
"cpoe_abs", "cpoe_rel")

names(df_res_sbg_18) <- vec_col_names

#keep only municipalities; id should not end on 00 or 99
df_res_sbg_18_wide <- df_res_sbg_18 %>%
filter(!str_detect(code, regex("(99)|(00)$"))) %>%
filter(str_detect(code, regex("\\d{5}")))

df_res_sbg_18_long <- df_res_sbg_18_wide %>%  
pivot_longer(
  cols=oevp_abs:last_col(),
  names_to="type",
  values_to="value_18"
) %>%
mutate(across(.cols=-c(code, region, type), .fns=as.numeric)) %>%
mutate(year=2018)


```


```{r}
#| code-summary: "Code: Get results for 2023"
df_res_sbg_23 <- readxl::read_xlsx(path=here::here("posts", "2023-03-17-state-elections-and-covid", "data", "sbg-LTW-2023.xlsx"), 
sheet="Stimmen",
skip=3, col_types = "text")  %>%
select(1:`...24`)
#ncol(df_res_sbg_23)

vec_col_names <- c(
  "code", "region", 
"eligible_total",  
"votes_total_abs", "votes_total_rel", 
"votes_invalid_abs", "votes_invalid_rel", 
"votes_valid_abs", 
# "votes_valid_rel" ,
"oevp_abs", "oevp_rel",
"spoe_abs", "spoe_rel",
"fpoe_abs", "fpoe_rel",
"greens_abs", "greens_rel",
"neos_abs", "neos_rel",
"kpoe_abs", "kpoe_rel",
"wirs_abs", "wirs_rel",
"mfg_abs", "mfg_rel")

names(df_res_sbg_23) <- vec_col_names

#keep only municipalities; id should not end on 00 or 99
df_res_sbg_23_wide <- df_res_sbg_23 %>%
filter(!str_detect(code, regex("(99)|(00)$"))) %>%
filter(str_detect(code, regex("\\d{5}")))

df_res_sbg_23_long <- df_res_sbg_23_wide %>%  
pivot_longer(
  cols=oevp_abs:last_col(),
  names_to="type",
  values_to="value_23"
) %>%
mutate(across(.cols=-c(code, region, type), .fns=as.numeric)) %>%
mutate(year=2023)
```


Calculate the changes between 2023 and 2018.

```{r}
#| code-summary: "Code: Calculate 2023 - 2018 changes for Salzburg"
df_res_sbg_municip_23 <- df_res_sbg_23_long %>%
left_join(., df_res_sbg_18_long %>%
select(code, type, value_18),
by=c("code", "type")) %>%
mutate(value_18=replace_na(value_18, 0)) %>% # otherwise: number - NA = NA !!
mutate(value_diff=(value_23-value_18)*100) %>%
tidyr::separate_wider_delim(
  cols=type,
  delim="_",
  names=c("party", "value_type")
) %>%
mutate(state="sbg", .before=1)

df_res_sbg_municip_23  <- df_res_sbg_municip_23 %>%
filter(value_type=="rel") 
```

```{r}
df_res_sbg_municip_23 %>%
select(-state, -year, -value_18, -value_type, -votes_invalid_abs) %>%
reactable(.,
columns=list(
region=colDef(name="Municipality"),
eligible_total=colDef(name="eligible voters", format=colFormat(separators = T)),
votes_total_abs=colDef(name="votes casted", format=colFormat(separators = T)),
votes_total_rel=colDef(name="turnout",
format=colFormat(percent=T, digits = 2)),
votes_invalid_rel=colDef(name="% invalid votes", format=colFormat(percent=T, digits=2)),
votes_valid_abs=colDef(name="valid votes", format=colFormat(separators = T)),
value_23=colDef(name="vote share 23",
format=colFormat(percent=T, digits=2)),
value_diff=colDef(name="diff % points", format=colFormat(digits=2))
),
    compact = TRUE, 
    filterable=T,
    defaultPageSize = 5, 
    theme = fivethirtyeight()
  ) %>%
  add_title(title = "Election Results Salzburg 2023", font_size = 15) %>% 
  add_subtitle(subtitle = "Only municipal level.", font_size=12) 

```

## Combine Data

Finally, let's combine the results from Lower Austria, Carinthia, and Salzburg into one single dataframe, and keep only the columns of interest. Note that I also standardize and order party names.

```{r}
#| code-summary: "Code: Combine results, standardize party names"
#| code-fold: true

df_res_municip <- bind_rows(
  noe=df_res_noe_municip %>%
    select(
      municip_id=kenn_nr,
      municip_name=bezeichnung,
      party,
      change_perc=diff_percent),
  ktn=df_res_ktn_municip %>%
    select(municip_id,
           party=partei,
           change_perc=differenz_perc),
   sbg=df_res_sbg_municip_23 %>%
   select(municip_id=code,
   party,
   change_perc=value_diff),       
          .id = "state")

 
#Standardize party name
df_res_municip <- df_res_municip %>% 
  mutate(party=case_when(
    str_detect(party, regex("^VP$|vpnö|^oev", ignore_case=T)) ~ "ÖVP",
    str_detect(party, regex("^spoe")) ~ "SPÖ",
    str_detect(party, regex("^greens")) ~ "GRÜNE",
    str_detect(party, regex("^fpoe")) ~ "FPÖ",
    str_detect(party, regex("^neos")) ~ "NEOS",
    str_detect(party, regex("^kpoe")) ~ "KPÖ",
    str_detect(party, regex("mfg")) ~ "MFG",
    .default = party
  ))

```

## Select parties 
```{r}
#| code-summary: "Code: Select parties"

vec_parties_filter <- c(
  "ÖVP", "SPÖ", "FPÖ","GRÜNE", "NEOS", 
  "MFG", 
  #"ZIEL",
  # "KÖFER", 
  #"STARK", 
  "BFK", 
  #"VÖ",
  "KPÖ"#,
  # "WIRS"
  )

df_res_municip <- df_res_municip %>%
filter(party %in% vec_parties_filter) %>%
mutate(party=fct_drop(party))

#put large parties up front
lvls_party <- c("ÖVP", "SPÖ", "FPÖ", "GRÜNE", "NEOS")
# levels(df_res_municip$party)

df_res_municip <- df_res_municip %>%
  mutate(party=forcats::fct_relevel(party, lvls_party)) 
```

# COVID DATA

With the electoral results now ready, let's add the data on Covid vaccination rates on the municipal level.

```{r}
#| code-summary: "Code: Import Covid vaccination data and add to electoral data"
#| cache: false

#import covid vaccination data
df_covid <- readr::read_csv2(file="https://info.gesundheitsministerium.gv.at/data/COVID19_vaccination_municipalities_v202210.csv")

df_covid_2 <- df_covid %>% 
  mutate(across(.cols=contains("vaccination"), .fns=list(share=\(x) x/municipality_population))) %>% 
  mutate(municipality_id=as.character(municipality_id))

#add to municip data
df_res_municip_covid<- df_res_municip %>% 
  left_join(., 
            df_covid_2 %>% select((municipality_id), municipality_name, contains("share")),
            by=c("municip_id"="municipality_id"))

```

# CORRELATION {#sec-correlation}

With this dataset we can already replicate the analysis tweeted by Ennser-Jedenastik, and extend it to other selected parties.

```{r}
#| include: false
txt_caption <- "Data: 
https:&#47;&#47;www.ktn.gv.at&#47;wahlen&#47;ltwahl2023; https:&#47;&#47;www.salzburg.gv.at&#47;pol&#47;wahl&#47;land&#47;ltw23; https:&#47;&#47;www.noe.gv.at&#47;wahlen, https:&#47;&#47;info.gesundheitsministerium.gv.at&#47;data&#47;<br>Analysis & Graph: Roland Schmidt | @zoowalk | <span style='font-weight:400'>https:&#47;&#47;werk.statt.codes</span>"
```

```{r}
#| code-summary: "Code: Create regression plots"
#| column: page-right
#| fig-width: 10
#| fig-height: 6
#| code-fold: true

## coloring strip text
df_res_municip_covid <- df_res_municip_covid %>%
mutate(facet_txt_style=case_when(
  str_detect(party, regex("FPÖ|ÖVP")) ~ "**",
  .default = ""
)) %>%
# mutate(facet_txt=glue::glue("<span style='font-weight:{facet_txt_style}'>{party}</span>"))
mutate(facet_txt=glue::glue("{facet_txt_style}{party}{facet_txt_style}")) %>%
mutate(facet_txt=as_factor(facet_txt))

#levels(df_res_municip_covid$facet_txt)

## coloring strip background
library(ggh4x)

vec_party_levels <- levels(df_res_municip_covid$party)
strip_color <- ifelse(str_detect(vec_party_levels, regex("ÖVP|FPÖ")), "lightgrey", "white")
strip_color_scale <- setNames(strip_color, vec_party_levels)
# strip_color_scale

strip_background <- strip_themed(
  text_x = elem_list_text(face = 'bold'),
  background_x = elem_list_rect(fill = strip_color_scale, color="white")
  )

#df function
fn_reg_plot <- function(df, title) {

{{df}} %>%
ggplot(., aes(y=change_perc, 
                x=vaccination_1_share))+
  labs(
    y="change vote share",
    x="vaccination rate in municipality (1st shot)",
    title={{title}}
  )+
  geom_point(size=.5)+
  geom_smooth(method = "lm", color="orange",
  linewidth=.5)+
  stat_cor(aes(label = paste(after_stat(rr.label), after_stat(p.label), sep = "~`,`~")), # adds R^2 and p-value
           r.accuracy = 0.01,
           p.accuracy = 0.001,
           color="black",
          # fill="grey",
           label.x = 0.45, 
           label.y = -30, 
           size = 2) +
  stat_regline_equation(aes(label =after_stat(eq.label)), # adds equation to linear regression
                        color="black",
                        label.x = 0.45, 
                        label.y = -35, 
                        size = 2)+
  scale_x_continuous(label=scales::label_percent(scale=100),
    breaks=seq(.40,1,.20),
  position = "bottom")+
  scale_y_continuous(label=scales::label_percent(scale=1),
                     expand=expansion(mult=c(0.08,0.05)),
                     position="left")+
  facet_wrap2(
    facets="party",
    strip=strip_background,
    nrow=1,
    drop=F
  )+
  theme_ipsum_rc()+
theme(
  axis.title.y.left = element_text(size=rel(.7/9*11.5)),
  axis.title.x.bottom = element_text(size=rel(.7/9*11.5)),
  panel.grid.minor.x = element_blank(),
  panel.grid.minor.y=element_blank(),
  legend.position="none",
  strip.placement = "outside",
  axis.text.x.bottom = element_text(size=rel(.5),
  margin=ggplot2::margin(t=0, unit="cm")),
  axis.text.y.left = element_text(size=rel(.5)),
  plot.title=element_text(size=rel(0.9), margin=ggplot2::margin(b=0, unit="cm")),
  plot.title.position = "plot",
  panel.spacing.x = unit(0.25, "cm"),
  plot.margin=ggplot2::margin(t=0.3, b=0.1, unit="cm"),
  # strip.text.x.top=element_markdown(size=rel(0.7), hjust=.5,   margin=ggplot2::margin(b=0, unit="cm"))
  strip.text.x.top=element_text(size=rel(0.7), hjust=.5, face="bold",
  margin=ggplot2::margin(b=0, unit="cm")),
  strip.background=element_rect(color="white")
  
)+
coord_cartesian(ylim=c(-35,30), xlim=c(.40,1))

}

#nest municips & apply fn
df_plots_reg <- df_res_municip_covid %>% 
  filter(!is.na(change_perc)) %>% 
  tidyr::nest(., .by="state") %>% 
  mutate(state=case_when(
  state=="noe" ~ "Lower Austria",
  state=="ktn" ~ "Carinthia",
  state=="sbg" ~ "Salzburg"
)) %>%
mutate(plots=map2(.x=data, .y=state, .f=\(x, y) fn_reg_plot(df=x, title=y)))

txt_subtitle="Each dot represents one municipality."

li_plots <-  df_plots_reg %>%
pull(plots) 

#adjust axis titles
li_plots[[1]] <- li_plots[[1]]+theme(
axis.title.x.bottom = element_text(hjust=0))
li_plots[[2]] <- li_plots[[2]]+theme(axis.title.y.left=element_blank(),
axis.title.x.bottom = element_blank())
li_plots[[3]] <- li_plots[[3]]+theme(axis.title.y.left=element_blank(), 
axis.title.x.bottom = element_blank())

#comb plots
li_plots %>%
wrap_plots(., nrow=3)+ #3 rows = 3 states
plot_annotation(
  title="Electoral performance and COVID vaccination ratios",
  subtitle = txt_subtitle,
  caption=txt_caption,
  theme=theme(
    plot.title=element_text(family="Roboto Condensed", face="bold", size=rel(1.2)),
  plot.caption = element_markdown(family="Roboto Condensed", size=rel(.6)),
  plot.subtitle = element_markdown(family="Roboto Condensed Light",
  size=rel(.9), 
  lineheight = 1.2)
)
)
```

If you want to dig a bit deeper into the Salzburg results, hover over the dots in plot below to get details on each municipality.


```{r}
#| include: false
library(gdtools)
font_family_exists("Roboto Condensed")
register_gfont("Roboto Condensed")
addGFontHtmlDependency(family = "Roboto Condensed", "Roboto")
```

```{r}
#| code-summary: "Code: FPÖ electoral changes & covid status per municip"
#| fig-format: svglite


pl_sbg_f <- df_res_municip_covid %>%
filter(party=="FPÖ") %>%
filter(state=="sbg") %>%
ggplot(., aes(y=change_perc, 
                x=vaccination_1_share))+
  labs(
    y="change vote share (% points)",
    x="vaccination rate in municipality (1st shot)",
    title="State Elections Salzburg 2023 - FPÖ:\nChanges in electoral share and vaccination status per municipality",
    subtitle="Hover over dots to get details.",
    caption="Data: 
https:&#47;&#47;www.salzburg.gv.at&#47;pol&#47;wahl&#47;land&#47;ltw23; https:&#47;&#47;info.gesundheitsministerium.gv.at&#47;data&#47;<br>Analysis & Graph: Roland Schmidt | @zoowalk | <span style='font-weight:400'>https:&#47;&#47;werk.statt.codes</span>",
  )+
  geom_point_interactive(
    aes(tooltip=glue::glue("{municipality_name}
    change: {scales::percent(change_perc/100, accuracy=.1)},
    min. 1 Covid-shot: {scales::percent(vaccination_1_share,accuracy=.1)}")),
    size=.5)+
  geom_smooth(method = "lm", color="orange",
  linewidth=.5)+
  stat_cor(aes(label = paste(after_stat(rr.label), after_stat(p.label), sep = "~`,`~")), # adds R^2 and p-value
           r.accuracy = 0.01,
           p.accuracy = 0.001,
           color="black",
          # fill="grey",
           label.x = 0.45, 
           label.y = -30, 
           size = 2) +
  stat_regline_equation(aes(label =after_stat(eq.label)), # adds equation to linear regression
                        color="black",
                        label.x = 0.45, 
                        label.y = -35, 
                        size = 2)+
  scale_x_continuous(label=scales::label_percent(scale=100),
    breaks=seq(.50,.8,.10),
  position = "bottom")+
  scale_y_continuous(label=scales::label_percent(scale=1),
                     expand=expansion(mult=c(0.08,0.05)),
                     position="left")+
                     theme_ipsum_rc()+
theme(
  axis.title.y.left = element_text(size=rel(.7/9*11.5)),
  axis.title.x.bottom = element_text(size=rel(.7/9*11.5)),
  panel.grid.minor.x = element_blank(),
  panel.grid.minor.y=element_blank(),
  legend.position="none",
  axis.text.x.bottom = element_text(size=rel(.5),
  margin=ggplot2::margin(t=0, unit="cm")),
  axis.text.y.left = element_text(size=rel(.5)),
  plot.title=element_text(size=rel(1)),
  plot.subtitle=element_text(size=rel(0.8)),
  plot.title.position = "plot",
  plot.margin=ggplot2::margin(l=0, b=0.1, t=0.1, unit="cm"),
  plot.caption=element_markdown(size=rel(.5), hjust=0)
  )+
coord_cartesian(ylim=c(-10,30), xlim=c(.5,.85))

giraph_options=list(opts_hover(css = 
                               "fill:#FFA500;
                               color:#FFA500"),
                               opts_tooltip(css = 
                               "background-color:black;
                               color: white;
                               font-size: 80%;
                               font-family: Roboto Condensed;",
                               offx = 30, 
                               offy = -30,
                               delay_mouseout = 1000)
                               )
giraph_height=3

girafe(ggobj=pl_sbg_f,
       options=giraph_options,
       height_svg=giraph_height)
```
<br>
<br>

to be continued...

```{r}
#| include: false
knitr::knit_exit()
```

# BISCALE MAPS {#sec-biscale}

A while ago, I came across Chris Prener's [biscale](https://chris-prener.github.io/biscale/){target="_blank"}) package which allows you to put the interaction of two variables onto a map. So far I hadn't run into any analysis where I could have made use of it, but the present case - the interaction of vaccination rates and vote share change per municipality - seems to be a good fit to testdrive the package.

## Importing map data
Before doing so, however, we still need to combine our dataframe containing electoral and vaccination data with spatial data, allowing us to eventually plot the pertaining maps. The code chunk below does exactly this. The [source](https://www.data.gv.at/katalog/dataset/stat_gliederung-osterreichs-in-gemeinden14f53){target="_blank"} of the shapefiles for Lower Austria and Carinthia is Statistics Austria, the federal statistical office.

When joining the two dataframes, there's one thing to bear in mind: Some parties did not compete in all municipalities of a state. The intended result, however, should not only display those municipalities where the parties actually competed, but the maps for the entire state. Hence, a simple left join doesn't work. Instead, I define a function which is joining the map data of all municipalities for each party.

```{r}
#| eval: true
#| code-summary: "Code: Incorporate map data"
#| code-fold: true

#import map
map_municips_all <- read_sf(here::here("posts","2023-03-17-state-elections-and-covid","data","OGDEXT_GEM_1_STATISTIK_AUSTRIA_20230101","STATISTIK_AUSTRIA_GEM_20230101.shp"))

#keep only municipalities in Carinthia and Lower Austria
map_municips <- map_municips_all %>% filter(str_detect(g_id, regex("^2(0|1)|^3")))

#nrow(map_municips) #705 ok 132 + 573

#left-join with results for each party; ensures complete map/also where party didn't compete
vec_parties <- df_res_municip_covid %>% 
  filter(!is.na(change_perc)) %>% 
  distinct(party) %>% 
  pull()

fn_match_map_res <- function(party) {
  
left_join(map_municips,
          df_res_municip_covid %>% filter(party=={{party}}),
          by=c("g_id"="municip_id")) %>% 
    mutate(partei=party)

  }

df_map_res <- vec_parties %>% map(., fn_match_map_res, .progress=T) %>% 
  purrr::list_rbind() %>% 
  ungroup()

```

## Defining categories for biscale

In order to project the interaction of two variables onto a map, biscale splits continuous variables into a maximum of 4 categories (*dims* attribute). For each variable, I decided that each category should span the same width (*style=equal*). 

As for the vaccination ratio this is rather straight forward: Take the difference between the highest and the lowest ratio, and divide this space into four equally spaced intervals.

When it comes to parties' change of vote share (gain/loss in percentage points), there's one thing to consider: Rather than taking the difference between the maximum gain and maximum loss across all parties, I decided to take on an 'intra-party intra-state view' and take the differences only between each party's maximum/minimum. The rational behind it is my interest in seeing how each party's strong and weak electoral performance tie with municipality's vaccination ratio. If I would calculate the interval across all parties, it's likely that the electoral results of a party with comparatively little change would end up all i.e. in one lump category.
What this means in concrete terms will become clearer when showing the results. I just flag this already at this point, since its important when it comes to interpreting the eventual results.

To calculate these 'intra-party' categories, I define again a function which is applied to each party separately (rather than across the entire dataset at once).

```{r}
my_dims=3
my_pallette="BlueYl"
my_style="equal"
```

```{r}
#| eval: true
#| code-summary: "Code: Calculate biscale categories."
#| code-fold: true
#| warning: false

fn_bi_class <- function(party, state) {

#take only the election results of one party in one state 
    df_map_res_party_state <- df_map_res %>%
       filter(party=={{party}}) %>%
       filter(state=={{state}}) %>%
    mutate(vaccination_1_share=vaccination_1_share*100)

# calculate breaks to split election results and vaccination rates into 4 categories     
    bi_break_vals <- bi_class_breaks(df_map_res_party_state,
      x=change_perc,
      y=vaccination_1_share,
      style = my_style,
      dim=my_dims,
      dig_lab = 2,
      split = FALSE)
    #class(bi_break_vals)
 
# assign each municipality to one election result - vaccination ratio category
   bi_class(df_map_res_party_state, 
            x=change_perc, 
            y=vaccination_1_share, 
            style = my_style, 
            dim=my_dims) %>% 
     mutate(bi_break_vals_vec=list(bi_break_vals))
   
    }

# get unique combinations of state and party
df_state_party <- df_map_res %>% 
  distinct(party, state) %>% 
  filter(!is.na(party))

# apply function to all state - party combinations
df_map_res_bi_intra <- map2(df_state_party %>% pluck("party"),
       df_state_party %>% pluck("state"), 
       purrr::possibly(.f=\(x,y) fn_bi_class(party=x, state=y), 
                                  otherwise = NULL)) %>% 
  purrr::list_rbind()


```
 
```{r}
#| include: false
#| eval: false
#check
df_map_res_bi_intra %>% 
  count(party)

#check
check_intervals <- df_map_res_bi_intra %>% 
  group_by(party, state) %>% 
  slice_head(n=2) %>% 
  select(municip_name, bi_break_vals_vec) %>% 
  unnest_wider(bi_break_vals_vec) %>% 
  unnest(starts_with("bi"))


```

### across all parties
```{r}
#| eval: true
#| include: true

## interval across all parties (but within states?)
library(biscale)

bi_break_vals <- bi_class_breaks(df_map_res, 
    x=change_perc, y=vaccination_1_share, style = my_style, dim=my_dims, 
    dig_lab=2,
    split = FALSE)

df_map_res_bi_accross <- bi_class(df_map_res, x=change_perc, y=vaccination_1_share, style = my_style, dim=my_dims) %>% 
     mutate(bi_break_vals_vec=list(bi_break_vals))
  
```

## Produce maps

### define fn
```{r}
#| code-summary: "Code: Create biscale maps."
#| code-fold: true

#convert dataframe to sf object
#IMPORTANT
sf_map <- st_as_sf(df_map_res_bi_intra)
#sf_map <- st_as_sf(df_map_res_bi_accross)

#define function to plot each map
fn_plot <- function(party, state) {
  
#each state/each party  
#state <- "noe"
#party <- "FPÖ"

sf_plot_map<- sf_map %>% 
  #filter(!is.na(change_perc)) %>% 
  filter(state=={{state}}) %>% 
  filter(party=={{party}}) 

#create map
plot_map <- sf_plot_map %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = bi_class),
          color = "black", 
          size = 0.1, 
          show.legend = F) +
 bi_scale_fill(pal = my_pallette, 
               dim = my_dims) +
  labs(
    title = glue::glue("{state}: {party}")
  ) +
  bi_theme()+
    theme(plot.title=element_text(size=10))

bi_break_vals_vec <- unique(sf_plot_map$bi_break_vals_vec)  
flatten(bi_break_vals_vec)

#create legend  
plot_legend <- bi_legend(
  pal = my_pallette,
  dim=my_dims,
  xlab="Increase vote share",
  ylab="Increase vaccinatation share",
  size=8,
  breaks=flatten(bi_break_vals_vec),
  arrows=T)

df_legend_data <- sf_plot_map %>%
as_tibble() %>%
ungroup() %>%
count(bi_class) %>%
mutate(n_rel=n/sum(n)) %>%
tidyr::separate_wider_delim(cols=c(bi_class), delim = "-", names=c("x", "y")) %>%
mutate(across(.cols=c(x, y), as.numeric))


plot_legend_2 <- plot_legend+
labs(caption="Number of municipalities as labels")+
geom_text(data=df_legend_data,
  aes(x=x,
  y=y,
  label=n_rel %>% scales::percent(., accuracy=.1)))

#combine map and legend into one plot with patchwork package
plot_map+plot_legend_2+plot_layout(ncol=2, widths = c(3,1))

  
}

```

### apply fn

```{r}
#apply function
li_plots <-  map2(df_state_party %>% pluck("party"),
       df_state_party %>% pluck("state"), 
       .f=\(x, y) fn_plot(party=x, state=y), 
       .progress=T)
```
 
```{r}
df_plots <- li_plots %>% enframe(value="plot", name=NULL) %>%
dplyr::bind_cols(., df_state_party) 

vec_party_noe <- df_plots %>% filter(state=="noe") %>% pull("party")
vec_party_ktn <- df_plots %>% filter(state=="ktn") %>% pull("party")
vec_party_sbg <- df_plots %>% filter(state=="sbg") %>% pull("party")

vec_plot_noe <- df_plots %>% filter(state=="noe")  %>% pull("plot")
vec_plot_ktn <- df_plots %>% filter(state=="ktn")  %>% pull("plot")
vec_plot_sbg <- df_plots %>% filter(state=="sbg")  %>% pull("plot")

```


## Maps Lower Austria
:::: {.column-body-outset-right}
::: {.panel-tabset}
```{r}
#| results: asis
#| eval: true

walk2(.x=vec_party_noe, .y=vec_plot_noe, ~ {
  cat('## ', .x, '\n\n')
  
  print(.y)

  cat('\n\n')

})

```
:::
:::: 


## Maps Carinthia
:::: {.column-body-outset-right}
::: {.panel-tabset}
```{r}
#| results: asis
#| eval: false #CHECK

walk2(.x=vec_party_ktn, .y=vec_plot_ktn, ~ {
  cat('## ', .x, '\n\n')
  
  print(.y)

  cat('\n\n')

})

```
:::
:::: 




## Maps Salzburg
:::: {.column-body-outset-right}
::: {.panel-tabset}
```{r}
#| results: asis
#| eval: false #CHECK

walk2(.x=vec_party_sbg, .y=vec_plot_sbg, ~ {
  cat('## ', .x, '\n\n')
  
  print(.y)

  cat('\n\n')

})

```
:::
:::: 

```{r}
knitr::knit_exit()
```

```{r}
#| eval: true

df_map_res_bi_intra_2<- df_map_res_bi_intra %>% 
  separate_wider_delim(cols=bi_class, delim = "-", names = c("bi_class_x", "bi_class_y")) %>% 
  mutate(bi_class_x=na_if(bi_class_x, "NA")) 

unique(df_map_res_bi_intra$state)

df_map_res_bi_intra_2 <- df_map_res_bi_intra_2 %>% 
  mutate(cat_vac_low=case_when(
    str_detect(bi_class_y, regex("[2-4]")) ~ "other",
    .default="low"))

```
 
# DOT PLOT {#sec-dotplots}

Here's an alternative visualization approach of the same data. Let's divide municipalities into a category with low and high vaccination ratios and contrast the electoral performance of parties' between these groups. 

## quantiles
```{r}
quantile_values <- quantile(df_res_municip_covid$vaccination_1_share, 
probs=seq(0,1,.25), na.rm=TRUE)

df_res_municip_covid$cat_vac <- cut(df_res_municip_covid$vaccination_1_share, quantile_values, include.lowest=T, labels=F)

df_res_municip_covid %>%
group_by(cat_vac) %>%
summarise(n=n())
```

## ntile

```{r}
x <- seq(1:10)
ntile(x, 4)
quantile(x)
```

##  cut

```{r}
df_res_municip_covid_cut <- df_res_municip_covid %>%
mutate(cat_vac_interval=cut(vaccination_1_share, 
breaks=4, include.lowest=T)) %>%
arrange(vaccination_1_share) %>%
group_by(cat_vac_interval) %>%
mutate(cat_vac=cur_group_id()) %>%
mutate(cat_vac_low=case_when(
  cat_vac>1 ~ "other",
  .default = "low"
))

levels(df_res_municip_covid_cut$party)

```

```{r}
#| column: page-right
#| fig-hight: 9

col_low <- "black"
col_other <- "grey"

fn_rain_plot <- function(df, title) {

{{df}} %>%
ggplot(.,
aes(x=cat_vac_low,
  y=change_perc,
  # fill=cat_vac_low,
  color=cat_vac_low))+
labs(
  title={{title}}
  )+
geom_half_boxplot( 
side="r",
nudge=0.2,
errorbar.draw = T,
fill="transparent",
outlier.color=NA)+
geom_half_point(
  side="l",
  aes(alpha=0.1)

)+
scale_y_continuous(
  breaks=seq(-30,30,15),
  position="left",
  label=scales::label_percent(scale=1, accuracy=1))+
scale_x_discrete(position="top")+
scale_color_manual(values=c(low=col_low, other=col_other))+
scale_fill_manual(values=c(low=col_low, other=col_other))+
theme(
  legend.position="none"
)+
#ggthemes::theme_fivethirtyeight()+
theme_ipsum_rc()+
theme(
  axis.title.y.left = element_blank(),
  axis.title.x.top = element_blank(),
  panel.grid.major.x = element_blank(),
  panel.grid.minor.y=element_blank(),
  legend.position="none",
  strip.placement = "outside",
  # strip.text.y.left=element_text(face="bold", angle=0, 
  # hjust=1,
  # vjust=1),
  #plot.caption = element_markdown(),
  #plot.subtitle = element_markdown(),
  axis.text.x.top = element_text(size=rel(.7),
  margin=ggplot2::margin(t=0, unit="cm")),
  axis.text.y.left = element_text(size=rel(.7)),
  plot.title=element_text(size=rel(0.9), margin=ggplot2::margin(b=.1, unit="cm")),
  plot.title.position = "plot",
  panel.spacing.x = unit(0.1, "cm"),
  plot.margin=ggplot2::margin(t=0.2, b=0, unit="cm"),
  strip.text.x.top=element_text(size=rel(0.7), hjust=.5,
  margin=ggplot2::margin(b=0, unit="cm"))
)+
facet_wrap(vars(party), 
nrow=1, 
#ncol=9, 
drop=F)+
coord_cartesian(ylim=c(-35,30))

}


levels(df_res_municip_covid_cut$party)


df_plots <- df_res_municip_covid_cut %>%
filter(party %in% vec_parties_filter)  %>%
mutate(party=fct_drop(party)) %>%
ungroup() %>%
tidyr::nest(., .by="state") %>%
mutate(state=case_when(
  state=="noe" ~ "Lower Austria",
  state=="ktn" ~ "Carinthia",
  state=="sbg" ~ "Salzburg"
)) %>%
mutate(plots=map2(.x=data, .y=state, .f=\(x, y) fn_rain_plot(df=x, title=y)))

txt_subtitle="The plot contrasts parties' electoral performance in municipalities with high and low vaccination ratios. Each dot represents the <br>electoral performance of a party in a specific municipality. Municipalities are grouped according the COVID vaccination ratio <br>(first shot) of their population: Municipalities within *the lowest 25 % of COVID vaccination ratios are in the category 'low'*, all others <br>are assigned to the group 'other'. Boxplot-halfs were added as summary indicators. Generally, the FPÖ performed stronger in municipalities with low vaccination ratios than in other municipalities."
#%>% str_replace_all(., regex("\\n"), "<br>")


df_plots %>%
pull(plots) %>%
wrap_plots(., ncol=1)+
plot_annotation(
  title="Electoral performance at 2023 State Elections and COVID vaccination ratios",
  subtitle = txt_subtitle,
  caption=txt_caption,
  theme=theme(
    plot.title=element_text(family="Roboto Condensed", face="bold", size=rel(1.2)),
  plot.caption = element_markdown(family="Roboto Condensed", size=rel(.6)),
  plot.subtitle = element_markdown(family="Roboto Condensed Light",
  size=rel(.9), 
  lineheight = 1.2)
)
)


```
