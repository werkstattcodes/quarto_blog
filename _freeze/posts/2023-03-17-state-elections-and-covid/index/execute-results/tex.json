{
  "hash": "4befba6df12385f9063fc8d0f11d30b1",
  "result": {
    "markdown": "---\ntitle: \"State legislature elections and vaccination rates\"\ndescription: \"\"\n\ndate: 02-10-2023\n\ncategories:\n  - Austria\n  - COVID\n\nreference-location: margin\n\ntoc: true\nformat: \n  html: default\n  pdf: default\n\ndraft: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(sf)\nlibrary(patchwork)\nlibrary(reactable)\nlibrary(reactablefmtr)\nlibrary(ggpubr)\nlibrary(ggh4x)\nlibrary(biscale)\n```\n:::\n\n\n\n# JUST THE RESULTS, PLEASE!\n\n# CONTEXT\n\nThis post is a \"quick\" look at the most recent state-level elections in Austria, namely in Lower Austria and Carinthia. Following the publication of the results, polsci prof Laurenz Ennser-Jedenastik pointed out in a tweet the rather remarkable relation between municipalities' rates of COVID vaccinations and the performance of the extreme-right Freedom Party (FPÖ) in Lower Austria.\n\nThis post adds little substantively new, but is rather an exercise in demonstrating\n\na\\) how to extract electoral data from the rather intricate formats they were published in by the electoral authorities. Here we're dealing with multi-column headers in an xlsx file and a nested html pages; @sec-getting-electoral-data\n\nb\\) how to display bivariate data on a map, i.e. the relation between municipal vaccination rates and the municipal vote share change of a party, and\n\nc\\) a few smaller side kicks along the way (e.g. extending the analysis to all parties).\n\n# GETTING ELECTORAL DATA {#sec-getting-electoral-data}\n\nObtaining electoral data is not a big thing, as it should be. Getting them in a format, which is amenable to further analysis, e.g. in R, is another story. While there certainly has been some progress regarding Open Data, nevertheless, quite frequently, a considerable amount of data wrangling is necessary.\n\n## Lower Austria\n\nWith the earlier elections in Lower Austria, the results came [inter alia](https://www.noe.gv.at/wahlen/L20231/Download.html%7Btarget=%22_blank%22%7D) as a standard xlsx file, however, with these column headers:\n\n![](noe_results.PNG)\n\nBelow the necessary steps to eventually obtain a tidy dataframe. The [\\`janitor\\` package](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html%7Btarget=%22_blank%22%7D) once again turns out to be a very helpful tool.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres_noe <- readxl::read_xls(path=here::here(\"posts\",\"2023-03-17-state-elections-and-covid\",\"data\", \"noe_lw23.xls\"))\n\n#get party names\nvec_parties_noe <- res_noe %>% \n  slice(2) %>% \n  unlist(use.names=F) %>% \n  na.omit() %>% as.character()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_parties_noe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"VPNÖ\"  \"SPÖ\"   \"FPÖ\"   \"GRÜNE\" \"NEOS\"  \"MFG\"   \"KPÖ\"   \"ZIEL\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#take body table\ndf_res_noe_clean <- res_noe %>% \n  janitor::find_header()\n\n#make row number 3 auxiliary column names\ndf_res_noe_clean <- res_noe %>% \n  janitor::row_to_names(., row_number=3, remove_rows_above = T) %>% \n  clean_names() %>% \n  pivot_longer(.,cols=matches(\"stimmen|ant_|diff_\"))\n```\n:::\n\n\n\nAdd party names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Assign party names to columns\ndf_res_noe_clean <- df_res_noe_clean %>% \n  mutate(party=case_when(\n    str_detect(name, regex(\"^Stimmen$\")) ~ vec_parties_noe[[1]],\n    str_detect(name, regex(\"^ant_percent$\")) ~ vec_parties_noe[[1]],\n    str_detect(name, regex(\"^diff_percent$\")) ~ vec_parties_noe[[1]],\n    str_detect(name, regex(\"_2$\")) ~ vec_parties_noe[[2]],\n    str_detect(name, regex(\"_3$\")) ~ vec_parties_noe[[3]],\n    str_detect(name, regex(\"_4$\")) ~ vec_parties_noe[[4]],\n    str_detect(name, regex(\"_5$\")) ~ vec_parties_noe[[5]],\n    str_detect(name, regex(\"_6$\")) ~ vec_parties_noe[[6]],\n    str_detect(name, regex(\"_7$\")) ~ vec_parties_noe[[7]],\n    str_detect(name, regex(\"_8$\")) ~ vec_parties_noe[[8]],\n    .default = NA\n  ))\n```\n:::\n\n\n\nKeep only municipalities. Note that I limit my analysis here to the change of the electoral share on the municipal level. I don't consider here the mere vote share, but the analysis could be easily extended, if deemed relevant.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_res_noe_municip <- df_res_noe_clean %>% \n  filter(str_detect(kenn_nr, regex(\"\\\\d{5}\"))) %>% \n  select(kenn_nr, bezeichnung, name, value, party) %>% \n  filter(str_detect(name, regex(\"^diff_percent\"))) %>% \n  mutate(diff_percent=as.numeric(value)) %>% \n  select(-name, -value)\n  \nn_distinct(df_res_noe_municip$kenn_nr) #573 OK\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 573\n```\n:::\n:::\n\n\n\nAnd with this we obtained a cleaned version of the election results for Lower Austria.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_res_noe_municip %>% \n  reactable(\n    compact = TRUE, \n    filterable=T,\n    defaultPageSize = 5, \n    theme = fivethirtyeight()\n  ) %>%\n  add_title(title = \"Election Results Lower Austria 2023\", font_size = 15) %>% \n  add_subtitle(subtitle = \"Only municipal level.\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Carinthia\n\nCarinthia's election results are published on dedicated website by the state authorities. Have a look [here](https://www.ktn.gv.at/wahlen/ltwahl2023%7Btaget=%22_blank%22%7D). As you can see, the main page comprises a left-hand panel with links to each of the municipal results (and other categories). In turn, each of these municipal sub-pages contains a table with election results, the data in which I am actually interested in.\n\nTo collect these data, let's take the following steps:\n\n1\\) From left-hand panel on the overview page, extract all links leading to municipal subpages. The pertaining css-selector targets html elements of with the id 'gemeinde'. Since this selector also captures aggregate categories for wider electoral districts which we do not want, they have to be removed. Conveniently, they are all spelled in capital letter, what makes it easy to match via a regular expression and filter them out.\n\nGet links to sub/municipality-pages with results.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlink_overview <- \"https://www.ktn.gv.at/wahlen/ltwahl2023\"\n\nmain <- rvest::session(link_overview)\n\n#get links\nres_links <- main %>% xml2::read_html() %>% \n  rvest::html_elements(\"#gemeinde a\") %>% \n  rvest::html_attr(\"href\")\n\n#get names\nres_names <- main %>% xml2::read_html() %>% \n  rvest::html_elements(\"#gemeinde a\") %>% \n  rvest::html_text()\n\n#combine links and names to a tibble\ndf_res <- tibble(links=res_links, names=res_names)\n\ndf_res %>% \n  filter(str_detect(links, regex(\"[A-Z]\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 2\n  links             names         \n  <chr>             <chr>         \n1 lt2023_2A000.html 1 Klagenfurt  \n2 lt2023_2D000.html 2 Kärnten Ost \n3 lt2023_2B000.html 3 Villach     \n4 lt2023_2C000.html 4 Kärnten West\n```\n:::\n\n```{.r .cell-code}\ndf_mun <- df_res %>% \n  #remove aggregate categories\n  filter(!str_detect(links, regex(\"[A-Z]\"))) %>% \n  #complete links to get entire address\n  mutate(link_complete=glue::glue(\"https://www.ktn.gv.at/wahlen/ltwahl2023/{links}\"))\n```\n:::\n\n\n\nHere the dataframe with all sub-page links.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_mun \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 132 x 3\n   links             names              link_complete                           \n   <chr>             <chr>              <glue>                                  \n 1 lt2023_20101.html Klagenfurt am Ws.  https://www.ktn.gv.at/wahlen/ltwahl2023~\n 2 lt2023_20402.html Ebenthal           https://www.ktn.gv.at/wahlen/ltwahl2023~\n 3 lt2023_20403.html Feistritz i. R.    https://www.ktn.gv.at/wahlen/ltwahl2023~\n 4 lt2023_20405.html Ferlach            https://www.ktn.gv.at/wahlen/ltwahl2023~\n 5 lt2023_20409.html Grafenstein        https://www.ktn.gv.at/wahlen/ltwahl2023~\n 6 lt2023_20412.html Keutschach am See  https://www.ktn.gv.at/wahlen/ltwahl2023~\n 7 lt2023_20414.html Köttmannsdorf      https://www.ktn.gv.at/wahlen/ltwahl2023~\n 8 lt2023_20415.html Krumpendorf am Ws. https://www.ktn.gv.at/wahlen/ltwahl2023~\n 9 lt2023_20416.html Ludmannsdorf       https://www.ktn.gv.at/wahlen/ltwahl2023~\n10 lt2023_20442.html Magdalensberg      https://www.ktn.gv.at/wahlen/ltwahl2023~\n# ... with 122 more rows\n```\n:::\n:::\n\n\n\n2\\) With the links to all municipal pages now available, the next step is about extracting the table with the electoral data. To so, I define a function which is subsequently mapped to each subpage link. The css selector allowing us to capture the table is on each page class '.bausteinausw3_bo'.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn_get_res_municip <- function(link_municip) {\n  \n# link_municip <- \"https://www.ktn.gv.at/wahlen/ltwahl2023/lt2023_20402.html\"\n  \n#Extract table   \ndf_res_municip <- link_municip %>% \n  xml2::read_html() %>% \n  rvest::html_elements(\".bausteinausw3_bo\") %>% \n  rvest::html_table() %>% \n  .[[1]] \n\n#Filter the results    \ndf_res_municip %>% \n  janitor::clean_names() %>% \n  filter(!str_detect(partei, regex(\"^Partei$|Gesamt|Ungültig|Gültig\"))) %>% \n  mutate(partei=str_remove(partei, regex(\"^.+?(?=[A-Z])\"))) %>% \n  rename_with(., .fn=\\(x) str_replace(x, \"_2\", \"_perc\"), .cols=ends_with(\"_2\")) %>% \n  mutate(across(.cols=-partei, .fns=\\(x) parse_number(x, locale=locale(decimal_mark=\",\")))) %>% \n  mutate(link_municip=link_municip) %>% \n  mutate(municip_id=str_extract(link_municip, regex(\"\\\\d+(?=\\\\.html$)\")))\n\n}  \n```\n:::\n\n\n\nApply the function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Map links\ndf_res_ktn_municip<- df_mun %>% \n  pull(link_complete) %>% \n  map(., .f=\\(x) fn_get_res_municip(link_municip = x), .progress=T) %>% \n  purrr::list_rbind() \n```\n:::\n\n\n\nHere the election results for Carinthia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_res_ktn_municip %>% \n    reactable(\n    compact = TRUE, \n    filterable=T,\n    defaultPageSize = 5, \n    theme = fivethirtyeight()\n  ) %>%\n  add_title(title = \"Election Results Carinthia 2023\", font_size = 15) %>% \n  add_subtitle(subtitle = \"Only municipal level.\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Combine Data\n\nFinally, let's combine the results from Lower Austria and Carinthia into one single dataframe, and keep only the columns of interest. Note that I also standardize the party name of the ÖVP.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_res_municip <- bind_rows(\n  noe=df_res_noe_municip %>%\n    select(\n      municip_id=kenn_nr,\n      municip_name=bezeichnung,\n      party,\n      change_perc=diff_percent),\n  ktn=df_res_ktn_municip %>%\n    select(municip_id,\n           party=partei,\n           change_perc=differenz_perc),\n          .id = \"state\")\n\n# Standardize party name\n\ndf_res_municip <- df_res_municip %>% \n  mutate(party=case_when(\n    str_detect(party, regex(\"^VP$|vpnö\", ignore_case=T)) ~ \"ÖVP\",\n    .default = party\n  ))\n```\n:::\n\n\n\n# COVID DATA\n\nWith the electoral results now ready, let's add the data on Covid vaccination rates on the municipal level.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_covid <- readr::read_csv2(file=\"https://info.gesundheitsministerium.gv.at/data/COVID19_vaccination_municipalities_v202210.csv\")\n\ndf_covid_2 <- df_covid %>% \n  mutate(across(.cols=contains(\"vaccination\"), .fns=list(share=\\(x) x/municipality_population))) %>% \n  mutate(municipality_id=as.character(municipality_id))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_res_municip_covid<- df_res_municip %>% \n  left_join(., \n            df_covid_2 %>% select((municipality_id), municipality_name, contains(\"share\")),\n            by=c(\"municip_id\"=\"municipality_id\"))\n\nnrow(df_res_municip)==nrow(df_res_municip_covid)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n# CORRELATION\n\nWith this dataset we can already replicate the analysis tweeted by Ennser-Jedenastik, and extend it to other parties than the FPÖ.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code: Create regression plots\"}\ndf_res_municip_covid %>% \n  filter(!is.na(change_perc)) %>% \n  ggplot(., aes(y=change_perc, \n                x=vaccination_1_share))+\n  labs(\n    y=\"change of vote share in municipality\",\n    x=\"vaccination rate in municipality\",\n    title=\"Correlation of electoral win/loss and covid vaccination rate\",\n    subtitle=\"Vaccination rate: % of municipality's population with at least on shot.\",\n    caption=\"Data: \"\n  )+\n  geom_point()+\n  geom_smooth(method = \"lm\", color=\"orange\")+\n  # stat_cor(aes(label = paste(..rr.label.., ..p.label.., sep = \"~`,`~\")), # adds R^2 and p-value\n  stat_cor(aes(label = paste(after_stat(rr.label), after_stat(p.label), sep = \"~`,`~\")), # adds R^2 and p-value\n           r.accuracy = 0.01,\n           p.accuracy = 0.001,\n           color=\"black\",\n          # fill=\"grey\",\n           label.x = 0.45, \n           label.y = -20, \n           size = 3) +\n  stat_regline_equation(aes(label =after_stat(eq.label)), # adds equation to linear regression\n                        color=\"black\",\n                        label.x = 0.45, \n                        label.y = -17, \n           #             fill=\"grey\",\n                        size = 3)+\n  # scale_y_continuous(label=scales::label_percent(scale=1))+\n  scale_x_continuous(label=scales::label_percent(scale=100),\n  position = \"top\")+\n  scale_y_continuous(label=scales::label_percent(scale=1),\n                     expand=expansion(mult=c(0,0)),\n                     position=\"left\")+\n  facet_grid2(\n    rows=vars(party),\n    cols=vars(state),\n    axes=\"x\",\n    switch=\"y\",\n    labeller = labeller(state=c(ktn=\"CARINTHIA\", noe=\"LOWER AUSTRIA\")))+\n  ggthemes::theme_fivethirtyeight()+\n  theme(\n    panel.grid.minor.y = element_blank(),\n    strip.text.x = element_text(face=\"bold\"),\n    strip.text.y = element_text(face=\"bold\"),\n    axis.title.x.top = element_text(size=10, hjust=0, face = \"italic\"),\n    axis.title.y.left = element_text(size=10, hjust=1,\n    face=\"italic\"),\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/unnamed-chunk-16-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n# BISCALE\n\nA while ago, I came across Chris Prener's [biscale](https://chris-prener.github.io/biscale/){target=\"_blank\"}) package which allows you to put the interaction of two variables onto a map. So far I hadn't run into any analysis where I could have made use of it, but the present case - the interaction of vaccination rates and vote share change per municipality - seems to be a good fit to testdrive the package.\n\n## Importing map data\n\nBefore doing so, however, we still need to combine our dataframe containing electoral and vaccination data with spatial data, allowing us to eventually plot the pertaining maps. The code chunk below does exactly this. The [source](https://www.data.gv.at/katalog/dataset/stat_gliederung-osterreichs-in-gemeinden14f53){target=\"_blank\"} of the shapefiles for Lower Austria and Carinthia is Statistics Austria, the federal statistical office.\n\nWhen joining the two dataframes, there's one thing to bear in mind: Some parties did not compete in all municipalities of a state. The intended result, however, should not only display those municipalities where the parties actually competed, but the maps for the entire state. Hence, a simple left join doesn't work. Instead, I define a function which is joining the map data of all municipalities for each party.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"Code: Incorporate map data\"}\n#import map\nmap_municips_all <- sf::read_sf(here::here(\"posts\",\"2023-03-17-state-elections-and-covid\",\"data\",\"OGDEXT_GEM_1_STATISTIK_AUSTRIA_20230101\",\"STATISTIK_AUSTRIA_GEM_20230101.shp\"))\n\n#keep only municipalities in Carinthia and Lower Austria\nmap_municips <- map_municips_all %>% filter(str_detect(g_id, regex(\"^2(0|1)|^3\")))\n\n#nrow(map_municips) #705 ok 132 + 573\n\n#left-join with results for each party; ensures complete map/also where party didn't compete\nvec_parties <- df_res_municip_covid %>% \n  filter(!is.na(change_perc)) %>% \n  distinct(party) %>% \n  pull()\n\nfn_match_map_res <- function(party) {\n  \nleft_join(map_municips,\n          df_res_municip_covid %>% filter(party=={{party}}),\n          by=c(\"g_id\"=\"municip_id\")) %>% \n    mutate(partei=party)\n\n  }\n\ndf_map_res <- vec_parties %>% map(., fn_match_map_res, .progress=T) %>% \n  purrr::list_rbind() %>% \n  ungroup()\n```\n:::\n\n\n\n## Defining categories for biscale\n\nIn order to project the interaction of two variables onto a map, biscale splits continuous variables into a maximum of 4 categories (*dims* attribute). For each variable, I decided that each category should span the same width (*style=equal*). \n\nAs for the vaccination ratio this is rather straight forward: Take the difference between the highest and the lowest ratio, and divide this space into four equally spaced intervals.\n\nWhen it comes to parties' change of vote share (gain/loss in percentage points), there's one thing to consider: Rather than taking the difference between the maximum gain and maximum loss across all parties, I decided to take on an 'intra-party intra-state view' and take the differences only between each party's maximum/minimum. The rational behind it is my interest in seeing how each party's strong and weak electoral performance tie with municipality's vaccination ratio. If I would calculate the interval across all parties, it's likely that the electoral results of a party with comparatively little change would end up all i.e. in one lump category.\nWhat this means in concrete terms will become clearer when showing the results. I just flag this already at this point, since its important when it comes to interpreting the eventual results.\n\nTo calculate these 'intra-party' categories, I define again a function which is applied to each party separately (rather than across the entire dataset at once).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dims=3\nmy_pallette=\"BlueYl\"\nmy_style=\"equal\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"Code: Calculate biscale categories.\"}\nfn_bi_class <- function(party, state) {\n\n#take only the election results of one party in one state \n    df_map_res_party_state <- df_map_res %>%\n       filter(party=={{party}}) %>%\n       filter(state=={{state}}) %>%\n    mutate(vaccination_1_share=vaccination_1_share*100)\n\n# calculate breaks to split election results and vaccination rates into 4 categories     \n    bi_break_vals <- bi_class_breaks(df_map_res_party_state,\n      x=change_perc,\n      y=vaccination_1_share,\n      style = my_style,\n      dim=my_dims,\n      dig_lab = 2,\n      split = FALSE)\n    #class(bi_break_vals)\n \n# assign each municipality to one election result - vaccination ratio category\n   bi_class(df_map_res_party_state, \n            x=change_perc, \n            y=vaccination_1_share, \n            style = my_style, \n            dim=my_dims) %>% \n     mutate(bi_break_vals_vec=list(bi_break_vals))\n   \n    }\n\n# get unique combinations of state and party\ndf_state_party <- df_map_res %>% \n  distinct(party, state) %>% \n  filter(!is.na(party))\n\n# apply function to all state - party combinations\ndf_map_res_bi_intra <- map2(df_state_party %>% pluck(\"party\"),\n       df_state_party %>% pluck(\"state\"), \n       purrr::possibly(.f=\\(x,y) fn_bi_class(party=x, state=y), \n                                  otherwise = NULL)) %>% \n  purrr::list_rbind()\n```\n:::\n\n\n\n\n\n### across all parties\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## interval across all parties (but within states?)\nlibrary(biscale)\n\nbi_break_vals <- bi_class_breaks(df_map_res, \n    x=change_perc, y=vaccination_1_share, style = my_style, dim=my_dims, \n    dig_lab=2,\n    split = FALSE)\n\ndf_map_res_bi_accross <- bi_class(df_map_res, x=change_perc, y=vaccination_1_share, style = my_style, dim=my_dims) %>% \n     mutate(bi_break_vals_vec=list(bi_break_vals))\n```\n:::\n\n\n\n## Produce maps\n\n### define fn\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code: Create biscale maps.\"}\n#convert dataframe to sf object\n#IMPORTANT\nsf_map <- st_as_sf(df_map_res_bi_intra)\n#sf_map <- st_as_sf(df_map_res_bi_accross)\n\n#define function to plot each map\nfn_plot <- function(party, state) {\n  \n#each state/each party  \n#state <- \"noe\"\n#party <- \"FPÖ\"\n\nsf_plot_map<- sf_map %>% \n  #filter(!is.na(change_perc)) %>% \n  filter(state=={{state}}) %>% \n  filter(party=={{party}}) \n\n#create map\nplot_map <- sf_plot_map %>% \n  ggplot() +\n  geom_sf(mapping = aes(fill = bi_class),\n          color = \"black\", \n          size = 0.1, \n          show.legend = F) +\n bi_scale_fill(pal = my_pallette, \n               dim = my_dims) +\n  labs(\n    title = glue::glue(\"{state}: {party}\")\n  ) +\n  bi_theme()+\n    theme(plot.title=element_text(size=10))\n\nbi_break_vals_vec <- unique(sf_plot_map$bi_break_vals_vec)  \nflatten(bi_break_vals_vec)\n\n#create legend  \nplot_legend <- bi_legend(\n  pal = my_pallette,\n  dim=my_dims,\n  xlab=\"Increase vote share\",\n  ylab=\"Increase vaccinatation share\",\n  size=8,\n  breaks=flatten(bi_break_vals_vec),\n  arrows=T)\n\ndf_legend_data <- sf_plot_map %>%\nas_tibble() %>%\nungroup() %>%\ncount(bi_class) %>%\nmutate(n_rel=n/sum(n)) %>%\ntidyr::separate_wider_delim(cols=c(bi_class), delim = \"-\", names=c(\"x\", \"y\")) %>%\nmutate(across(.cols=c(x, y), as.numeric))\n\n\nplot_legend_2 <- plot_legend+\nlabs(caption=\"Number of municipalities as labels\")+\ngeom_text(data=df_legend_data,\n  aes(x=x,\n  y=y,\n  label=n_rel %>% scales::percent(., accuracy=.1)))\n\n#combine map and legend into one plot with patchwork package\nplot_map+plot_legend_2+plot_layout(ncol=2, widths = c(3,1))\n\n  \n}\n```\n:::\n\n\n\n### apply fn\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#apply function\nli_plots <-  map2(df_state_party %>% pluck(\"party\"),\n       df_state_party %>% pluck(\"state\"), \n       .f=\\(x, y) fn_plot(party=x, state=y), \n       .progress=T)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(li_plots)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n\n```{.r .cell-code}\ndf_plots <- li_plots %>% enframe() %>%\ndplyr::bind_cols(., df_state_party)\n\ndf_plots_noe <- df_plots %>%\nfilter(state==\"noe\") %>%\nselect(-state, -name) %>%\nrename(plot=value)\n\nvec_party <- df_plots_noe %>% pull(\"party\")\nclass(vec_party)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nvec_plot <- df_plots_noe %>% pull(\"plot\")\nclass(vec_plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\n\n:::: {.column-screen}\n::: {.panel-tabset}\n\n\n\n```{.r .cell-code}\nwalk2(.x=vec_party, .y=vec_plot, ~ {\n  cat('## ', .x, '\\n\\n')\n  \n  print(.y)\n\n  cat('\\n\\n')\n\n})\n```\n\n##  ÖVP \n\n![](index_files/figure-pdf/unnamed-chunk-25-1.pdf){fig-pos='H'}\n\n##  SPÖ \n\n![](index_files/figure-pdf/unnamed-chunk-25-2.pdf){fig-pos='H'}\n\n##  FPÖ \n\n![](index_files/figure-pdf/unnamed-chunk-25-3.pdf){fig-pos='H'}\n\n##  GRÜNE \n\n![](index_files/figure-pdf/unnamed-chunk-25-4.pdf){fig-pos='H'}\n\n##  NEOS \n\n![](index_files/figure-pdf/unnamed-chunk-25-5.pdf){fig-pos='H'}\n\n##  MFG \n\n![](index_files/figure-pdf/unnamed-chunk-25-6.pdf){fig-pos='H'}\n\n##  KPÖ \n\n![](index_files/figure-pdf/unnamed-chunk-25-7.pdf){fig-pos='H'}\n\n##  ZIEL \n\n![](index_files/figure-pdf/unnamed-chunk-25-8.pdf){fig-pos='H'}\n\n\n:::\n:::: \n\n\n# BARGRAPH\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_map_res_bi_intra_2<- df_map_res_bi_intra %>% \n  separate_wider_delim(cols=bi_class, delim = \"-\", names = c(\"bi_class_x\", \"bi_class_y\")) %>% \n  mutate(bi_class_x=na_if(bi_class_x, \"NA\"))\n\n\ndf_map_res_bi_intra_2 <- df_map_res_bi_intra_2 %>% \n  mutate(cat_vac_low=case_when(\n    str_detect(bi_class_y, regex(\"[2-4]\")) ~ \"other\",\n    .default=\"low\"))\n\nlibrary(ggh4x)\n\ndf_map_res_bi_intra_2 %>% \n # filter(str_detect(party, regex(\"FPÖ|ÖVP\"))) %>% \n  ggplot(., aes(x=interaction(cat_vac_low, party), \n                y=change_perc,\n                color=cat_vac_low))+\n  #geom_jitter()+\n  ggrain::geom_rain()+\n  scale_x_discrete(guide = guide_axis_nested(delim = \".\"), name = \"Party\")+\n  facet_wrap(vars(state))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-pdf/unnamed-chunk-26-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n# HEATMAPS\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_n_class <- df_map_res_bi_intra_2 %>% \n  filter(!is.na(bi_class_x)) %>%  #only in municipalities where party indeed ran\n  group_by(state, party, bi_class_x, bi_class_y) %>% \n  summarise(bi_class_n=n()) %>% \n  group_by(state, party) %>% \n  mutate(bi_class_rel=bi_class_n/sum(bi_class_n))\n\n\npl_n_class <- df_n_class %>% \n # filter(!is.na(bi_class_x)) %>%  #remove municipalities where party didn't compete\n  filter(state==\"noe\") %>% \n # filter(str_detect(party, regex(\"FPÖ|NEOS|ÖVP|GRÜNE\"))) %>% \n  ggplot()+\n  geom_raster(\n    aes(x=bi_class_x,\n        y=bi_class_y,\n        fill=bi_class_rel)\n  )+\n  geom_text(\n    aes(x=bi_class_x,\n    y=bi_class_y,\n    label=bi_class_rel %>% scales::percent(accuracy=.1))\n  )+\n  scale_fill_gradient(low=\"white\", high=\"red\")+\n  facet_grid(rows=vars(party),\n             cols=vars(state))\n```\n:::\n",
    "supporting": [
      "index_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}